<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用JavaScript实现焦点轮播图]]></title>
      <url>%2Fjs-lunbo.html</url>
      <content type="text"><![CDATA[使用JavaScript实现焦点轮播图原理各大网站都使用焦点轮播图来展示自己的图片，如淘宝、京东等。 焦点轮播图所用技能点：DOM操作、定时器、事件运用、JS动画、函数递归、无限滚动； 无限滚动实现：包含图片的父级标签要有一个属性overflow:hidden 来隐藏超出自身尺寸的内容;有style:left通过控制left值来实现滚动; 图片列表中要在开始和结束位置添加两张相同的附属图，使图片实现无缝连接。 使用html和css实现静态页面布局 父容器要承载图片、圆点下标、左右切换箭头，要让超出部分隐藏overflow：hidden、定位为position：relative； 图片的div要添加定位：position：absolute让它基于父容器relative，z-index：1使图片堆叠在第一层上； 圆点下标和左右切换箭头设置z-index：2，position：absolute，让其覆盖在图片上； 左右切换箭头在初始状态下设置为隐藏display：none，鼠标移上图片时使其显示display：block，鼠标移到箭头上时改变透明度RGBA，使箭头颜色加深； HTML代码 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;焦点轮播图&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/焦点轮播图.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container"&gt; &lt;div id="list" style="left: -600px"&gt; &lt;img src="images/5.jpg" alt="5"&gt; &lt;!-- 附属图实现无缝的滚动 --&gt; &lt;img src="images/1.jpg" alt="1"&gt; &lt;img src="images/2.jpg" alt="2"&gt; &lt;img src="images/3.jpg" alt="3"&gt; &lt;img src="images/4.jpg" alt="4"&gt; &lt;img src="images/5.jpg" alt="5"&gt; &lt;img src="images/1.jpg" alt="5"&gt; &lt;/div&gt; &lt;div id="buttons"&gt; &lt;span index="1" class="on"&gt;&lt;/span&gt; &lt;span index="2"&gt;&lt;/span&gt; &lt;span index="3"&gt;&lt;/span&gt; &lt;span index="4"&gt;&lt;/span&gt; &lt;span index="5"&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="javascript:;" id="prev" class="arrow"&gt;&amp;lt;&lt;/a&gt; &lt;a href="javascript:;" id="next" class="arrow"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;script type="text/javascript" src="js/焦点轮播图.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172*&#123; margin: 0; padding: 0; text-decoration :none;&#125;body&#123; padding: 20px;&#125;#container&#123; width: 600px; height: 400px; position: relative; border: 3px solid #333; overflow: hidden;&#125;#list&#123; height: 400px; width: 4200px; position: absolute; z-index: 1; /*设置元素的堆叠顺序*/&#125;#list img&#123; float: left;&#125;#buttons&#123; height: 10px; width: 100px; z-index: 2; bottom: 20px; left: 250px; position: absolute;&#125;#buttons span &#123; cursor: pointer; /*规定要显示的光标的类型（手指)*/ float: left; border: 1px solid #fff; width: 10px; height: 10px; border-radius: 50%; background: #333; margin-right: 5px;&#125;#buttons .on &#123; background: orangered;&#125;.arrow &#123; cursor: pointer; display: none; /*箭头隐藏*/ line-height: 39px; text-align: center; font-size: 36px; font-weight: bold; width: 40px; height: 40px; position: absolute; z-index: 2; top: 180px; background-color: RGBA(0,0,0,.3); /*透明度设置*/ color: #fff;&#125;.arrow:hover &#123; background-color: RGBA(0,0,0,.7);&#125;#container:hover .arrow &#123; display: block; /*箭头显示*/&#125;#prev &#123; left: 20px;&#125;#next &#123; right: 20px;&#125; JS动画实现箭头切换 -&gt; 无限滚动 -&gt; 按钮切换 -&gt; 延迟切换 -&gt; 自动播放 箭头切换 整个页面加载window.onload，获取元素 通过ID名获取页面中的元素（父容器、承载图片容器、圆点列表、箭头），赋值给一个变量 添加一个时间绑定，点击箭头时实现图片的切换 当点击右箭头时，改变left的值，向左移动，要减去一张图的宽度 获取图片容器的值，list.style.left = 自身的值再减去一张图片的宽度注意要把等号后面字符串使用parseInt函数转换为数字才可以进行减法，减去的图片宽度要加px单位 反方向同理，加上一张图片的宽度 左右箭头的写法很相似，只是加减不一样，可以封装成一个函数，通过参数的正负值实现加减 无限滚动：弥补左右键切换的空白 当前面的附属图比第一张大，最后一张附属图比最后一张小的时候，出现这两种情况时让它复位到真正的第一张或第五张图 判断是否滚到了辅助图上，滚到了让它归位 把常用的list.style.left，存到一个变量中，方便使用 添加圆点的切换功能，创建一个变量来承载当前存储的第几张图片/显示第个圆点 写一个函数，用来显示亮起小圆点的功能 圆点是数组，所以创建的变量要减去1才能对应上要显示的圆点，让它亮起来添加class名&lt;span index=&quot;1&quot; class=&quot;on&quot;&gt; 再绑定事件中左箭头index要加一，右箭头要减一，调用圆点函数让它点击时显示，每次点击箭头的时候都要改变index的值，使它对应到正确的图片上，调用showButton亮起对应的圆点 亮起自己的同时，让其他不亮，使用for循环，去掉所有的class，然后break退出循环，不再继续遍历元素节点 箭头点击时，当圆点index大于5时，让它归位为1，小于1时，归位为5，不到5时加1 圆点按钮切换 通过for循环遍历圆点，添加点击事件 点击按钮时，取到index值，就可以知道当前点击的是第几个按钮，要显示第几张图片 通过DOM2级方法getAttribute()获取到自定义（或自带）属性，为了计算再转换为数字var myIndex = parseInt(this.getAttribute(&#39;index&#39;)); 通过新的值减去旧的值获取偏移量var offset = -600 * (myIndex - index); 写一个判断，当这张图片是打开状态的，就什么都不做，用class=on来判断是否打开，return跳出，后面的代码不会再执行 123456if (animated) &#123; return;&#125;if (this.className == 'on') &#123; return;&#125; 动画函数 图片在一定时间内进行位移，要判断是否达到目标值，没有达到还要继续做位移 声明一个变量用offset总共的偏移量除以次数（位移总时间time除以位移间隔时间inteval),求出每次移动多少var speed = offset / (time / inteval); 判断speed小于0并且left值是否大于目标值newLeft或speed大于0并且left值小于目标值，这两种情况让它做位移speed &gt; 0 &amp;&amp; parseInt(list.style.left) &lt; left) || (speed &lt; 0 &amp;&amp; parseInt(list.style.left) &gt; left 在判断中放入定时器setTimeout一个函数不停的在一定的条件之后调用自身这种做法叫做递归 优化：声明一个变量，作为动画是否在运行的依据，开始状态为false表示没有运行var animated = false; //优化 自动播放 鼠标移开时自动播放，鼠标移上去时停止，通过定时器setTimeout和clearTimeout来实现的 设置定时器，让它隔几秒切换一次，相当于3秒钟调一次next.onclick（右箭头）事件 自动切换需要写两个函数来控制自动切换，声明一个变量来存放定时器不给任何值 鼠标移开时定时器执行，移上时清除定时器执行，要给整个容器加一个鼠标移入移开事件 鼠标不做任何事情时让它自动播放，调用函数 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107window.onload = function() &#123; var container = document.getElementById('container'); var list = document.getElementById('list'); var buttons = document.getElementById('buttons').getElementsByTagName('span'); var prev = document.getElementById('prev'); var next = document.getElementById('next'); var index = 1; //索引 var len = 5; var animated = false; //优化 var interval = 3000; //时间间隔 var timer; function showButton() &#123; for (var i = 0; i &lt; buttons.length; i++) &#123; if (buttons[i].className == 'on') &#123; buttons[i].className = ''; break; &#125; &#125; buttons[index - 1].className = 'on'; &#125; //按钮切换 next.onclick = function() &#123; if (animated) &#123; return; &#125; if (index == 5) &#123; index = 1; &#125; else &#123; index += 1; &#125; animate(-600); showButton(); &#125;//右切换 prev.onclick = function() &#123; if (animated) &#123; return; &#125; if (index == 1) &#123; index = 5; &#125; else &#123; index -= 1; &#125; animate(600); showButton(); &#125;//左切换 function play() &#123; timer = setTimeout(function() &#123; next.onclick(); play(); &#125;, interval); &#125; function stop() &#123; clearTimeout(timer); &#125; for (var i = 0; i &lt; buttons.length; i++) &#123; buttons[i].onclick = function() &#123; if (animated) &#123; return; &#125; if (this.className == 'on') &#123; return; &#125; var myIndex = parseInt(this.getAttribute('index')); var offset = -600 * (myIndex - index); animate(offset); index = myIndex; showButton(); &#125; &#125; function animate(offset) &#123; if (offset == 0) &#123; return; &#125; animated = true; var time = 300; //时间 var inteval = 10; //时间间隔 var speed = offset / (time / inteval); //速度 var left = parseInt(list.style.left) + offset; //改变值来实现滚动 var go = function() &#123; if ((speed &gt; 0 &amp;&amp; parseInt(list.style.left) &lt; left) || (speed &lt; 0 &amp;&amp; parseInt(list.style.left) &gt; left)) &#123; list.style.left = parseInt(list.style.left) + speed + 'px'; setTimeout(go, inteval); &#125; else &#123; list.style.left = left + 'px'; if (left &gt; -200) &#123; list.style.left = -600 * len + 'px'; &#125; if (left &lt; (-600 * len)) &#123; list.style.left = '-600px'; &#125; animated = false; &#125; &#125; //自动滚动 go(); &#125; container.onmouseover = stop(); container.onmouseout = play(); play();&#125; 总结焦点轮播图的实现需要耐心分析原理，掌握焦点轮播图所需的技能点，从而通过代码实现。 先写出静态页面html+css，注意属性值的设置。再用js一步一步写出箭头切换、按钮切换的函数，学会设置和清除定时器、递归调用函数，实现自动滚动播放。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MapReduce初探]]></title>
      <url>%2Fmapreduce-note.html</url>
      <content type="text"><![CDATA[MapReduce初探MapReduce是一个用于处理海量数据的分布式计算框架 MapReduce解决的问题： 数据分布式存储 作业调度 容错 机器间通信 MapReduce存储：HDFS 系统可靠性 可扩展性 并发处理 MapReduce思想：分治 分解 求解 合并 分：map 把复杂的问题分解为若干简单的任务 合：reduce MapReduce执行流程 实例WordCount 应用 数据统计 A/B test的需要，实验和对照统计对比各个指标 统计广告每天的展示、点击和消费总量 统计视频在一段时间内展示和点击数量，CTR指标 数据过滤 从日志中找到某一个条件数据 除去非法数据，保留合法数据 数据格式整理 同类汇聚 多份日志中，相同时间点、用户行为日志混合 类表格文件存储中，相同主键拼接相关的属性 历史的主数据与新增、修改数据合并 全局排序 混合日志按时间排序 多个字段排序 数据按名称排序 容错框架 易出错的服务，大数值计算 计算规模经常变化调整的服务 单进程程序。迅速提升执行计算效率]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法JavaScript学习(二)]]></title>
      <url>%2Fjs-algorithms-2.html</url>
      <content type="text"><![CDATA[数据结构与算法JavaScript学习(二)搜索算法顺序或线性搜索 123456789101112131415161718192021function ArrayList()&#123; var array=[]; this.insert=function(item)&#123; array.push(item); &#125;; this.toString=function()&#123; return array.join(); &#125;; //顺序搜索 this.sequentialSearch=function (item) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (item===array[i]) &#123; return i; &#125; &#125; return -1; &#125;;&#125; 二分搜索12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function ArrayList()&#123; var array=[]; this.insert=function(item)&#123; array.push(item); &#125;; this.toString=function()&#123; return array.join(); &#125;; //快速排序:分治递归 this.quickSort=function () &#123; quick(array,0,array.length-1); &#125;; //快排 var quick=function (array,left,right) &#123; var index; if (array.length&gt;1) &#123; index=partition(array,left,right); if (left&lt;index-1) &#123; quick(array,left,index-1); &#125; if (index&lt;right) &#123; quick(array,index,right); &#125; &#125; &#125;; //划分过程 var partition=function(array,left,right)&#123; var pivot=array[Math.floor((right+left)/2)],i=left,j=right;//选主元 while (i&lt;=j) &#123; while (array[i]&lt;pivot) &#123; i++; &#125; while (array[j]&gt;pivot) &#123; j--; &#125; if (i&lt;=j) &#123; swapQuickStort(array,i,j); i++; j--; &#125; &#125; return i; &#125;； //交换数组元素 var swapQuickStort=function (array,index1,index2) &#123; var aux=array[index1]; array[index1]=array[index2]; array[index2]=aux; &#125;; //二分搜索 this.binarySearch=function (item) &#123; this.quickSort();//快速排序 var low=0,high=array.length-1,mid,element; while (low&lt;=high) &#123; mid=Math.floor((low+high)/2); element=array[mid]; if (element&lt;item) &#123; low=mid+1; &#125;else if (element&gt;item) &#123; high=mid-1; &#125;else &#123; return mid; &#125; &#125; return -1; &#125;;&#125; 算法思想递归12345678//斐波那契数列:递归function fibonacci(num) &#123; if (num===1||num===2) &#123; return 1; &#125; return fibonacci(num-1)+fibonacci(num-2);&#125; 非递归12345678910//斐波那契数列:非递归function fib(num) &#123; var n1=1,n2=1,n=1; for (var i = 3; i &lt;= num; i++) &#123; n=n1+n2; n1=n2; n2=n; &#125; return n;&#125; 动态规划12345678910111213141516171819202122232425262728293031//动态规划：将大问题转化成小问题//最少硬币找零问题:找到n所需的最小硬币数function dpMinCoinChange(coins) &#123; var coins=coins; var cache=&#123;&#125;; this.makeChange=function (amount) &#123; var me=this; if (!amount) &#123;//判断为正 return []; &#125; if (cache[amount]) &#123;//判断是否有缓存 return cache[amount]; &#125; var min=[],newMin,newAmount; for (var i = 0; i &lt; coins.length; i++) &#123;//对每个面额计算 var coin=coins[i]; newAmount=amount-coin; if (newAmount&gt;=0) &#123; newMin=me.makeChange(newAmount); &#125; if (newAmount&gt;=0 &amp;&amp; (newMin.length&lt;min.length-1 || !min.length) &amp;&amp; (newMin.length || !newAmount)) &#123; //判断newAmount是否有效，最小硬币数是否最优，newMin和newAmount是否合理 min=[coin].concat(newMin); console.log('new Min '+min+ ' for '+amount); &#125; &#125; return (cache[amount]=min); &#125;&#125; 贪心策略123456789101112131415161718//贪心算法：近似求解，通过局部最优达到全局最优//最少硬币找零问题:找到n所需的最小硬币数function txMinCoinChange(coins)&#123; var coins=coins; this.makeChange=function(amount)&#123; var change=[],total=0; for (var i = coins.length; i &gt;= 0; i--) &#123;//对每个面额从大面额开始，从大到小依次 var coin=coins[i]; while (total+coin&lt;=amount) &#123; change.push(coin); total+=coin; &#125; &#125; return change; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB基础学习]]></title>
      <url>%2Fmongo-note.html</url>
      <content type="text"><![CDATA[MongoDB基础学习 MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展，总结知识点分享给与我一样刚入门MongoDB的人。 基本概念 数据库：数据库是一个集合的物理容器。每个数据库获取其自己设定在文件系统上的文件。一个单一的MongoDB服务器通常有多个数据库 集合：集合是一组MongoDB的文件。它与一个RDBMS表是等效的。一个集合存在于数据库中。集合不强制执行模式。集合中的文档可以有不同的字段。 文档：文档是一组键值对。文档具有动态模式。动态模式是指，在同一个集合的文件不必具有相同一组集合的文档字段或结构，并且相同的字段可以保持不同类型的数据。 文档是MongoDB中数据的基本单元 在MongoDB中，一个MongoDB实例可以承载多个数据库，每个数据库拥有0或多个集合，一个集合拥有多个文档 在同一个MongoDB服务器上存放多个应用那个程序或用户的数据，需要使用不同的数据库 使用BSON格式 使用MongoDB在哪些场景 大而复杂的数据 移动和社会基础设施数据 内容管理和交付 用户数据管理 数据中心 初始化的数据库 admin：root数据库，有数据库所以权限 local：存储所以本地集合 config：存储分片信息 基本数据类型 null：空或不存在 布尔型：true或false 数值：默认64位浮点型数值 字符串：UTF-8 日期：自新世纪以来经过的毫秒，不存储时区 正则表达式：与js语法相同 数组：数据列表或数据集 内嵌文档：对象嵌套 对象 对象id是一个12字节的ID，是一个由24个十六进制数字组成的字符串，作为文档唯一标识，一秒钟最多允许每个进程拥有2563个不同的ObjectId ObjectId前四个字节是从标准纪元开始的时间戳，单位为秒 接下来3个字节是所在主机的唯一标识符，机器主机名的散列值 接下来2个字节来自产生ObjectId的进程的进程标识符PID 最后3个字节是一个自动增加的计数器 二进制数据 代码 MongoDB shell 启动时会连到test数据库，并将数据库连接赋值给全局变量db 连接到不同的数据库或服务器 123 mongo --nodbconnect=new Mongo(&quot;host:27017&quot;) db=connect.getDB(&quot;myDB&quot;) 帮助 help db.foo.update，方法不加括号可查看相应函数的源码 创建.mongorc.js 频繁加载的脚本 移除比较危险的shell辅助函数 指定--norc，可以禁止加载.mongorc.js 定制shell提示：将prompt变量设为一个字符串或函数 编辑符合变量：设置EDITOR 四个基本操作：创建、读取、更新、删除（CRUD）创建 单个插入：insert 批量插入：batchInsert 删除 删除文档：remove，可接受一个查询文档作为参数 删除集合：drop，不能指定条件 更新 update：必须接受两个参数，第一个匹配待更新文档，第二个是修改器文档。接受第三个参数，若为true，则表示这是upsert。接受第四个参数，若为true，则表示更新所有匹配的文档。 原子性的更新修改器 $set：指定一个字段的值 $unset：删除指定键 $inc：增加已有键的值，不存在则创建，只能用于整型、长整型或双精度浮点型的值 $push：向已有数组末尾加入一个元素 $each：通过一次$push操作添加多个值 $slice：设置最大长度，必须为负整数，相当于建立队列，保留最后的元素 $sort：清理元素 $addToSet：添加新数据，可以避免重复 $pop：可以从数组任何一端删除元素 $pull：删除所有匹配的文档 upsert：若未找到符合更新条件的文档，则以此为条件创建新文档；若找到相应文档，正常更新。可用于创建又可用于更新。 读取find和findOne 第一个参数用于指定查询条件 第二个参数指定想要返回的键 查询条件 $lt,$lte,$gt,$gte,$ne对应小于、小于等于、大于、大于等于、不等于 $in：用来查询一个键的多个值 $or：在多个键中查询任意给定值 1db.raffle.find(&#123;"$or":[&#123;"tricket_no":&#123;"in":[755,542,390]&#125;&#125;,&#123;"winner":true&#125;]&#125;) $not：用来查询与特定模式不匹配的文档 $exists：判定键值是否存在 $maxscan：指定本次查询文档数量的上限 $min：强制指定下边界 $max：强制指定上边界 $showDiskLoc：用于显示结果在磁盘的位置 数组查询 $all：通过多个元素匹配数组 $size：查询特定长度的数组 $slice：返回某个键匹配的数组元素的一个子集 $elemMatch：指定一组添加，只可用于数组 查询函数 limit：限制返回数量 skip：忽略一定数量的结果 sort：接受一个对象作为参数，键为文档键名，值为排序方向（1为升序，-1为降序）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FreeCodeCamp学习笔记（四）]]></title>
      <url>%2FFreeCodeCamplearn4.html</url>
      <content type="text"><![CDATA[FreeCodeCamp学习笔记（四）JavaScript基础循环 一个条件语句只能执行一次代码，而一个循环语句可以多次执行代码。 JavaScript 中最常见的循环就是“for循环”。 for循环中的三个表达式用分号隔开：for ([初始化]; [条件判断]; [计数器]) 初始化语句只会在执行循环开始之前执行一次。它通常用于定义和设置你的循环变量。 条件判断语句会在每一轮循环的开始执行，只要条件判断为 true 就会继续执行循环。当条件为 false的时候，循环将停止执行。这意味着，如果条件在一开始就为 false，这个循环将不会执行。 计数器是在每一轮循环结束时执行，通常用于递增或递减。 for循环可以按照我们指定的顺序来迭代，通过更改我们的 计数器，我们可以按照偶数顺序来迭代。 for循环也可以逆向迭代，只要我们定义好合适的条件。 迭代输出一个数组的每个元素是 JavaScript 中的常见需求， for 循环可以做到这一点。记住数组的索引从零开始的，这意味着数组的最后一个元素的下标是：数组的长度 - 1。 如果你有一个二维数组，可以使用相同的逻辑，先遍历外面的数组，再遍历里面的子数组。对于内部循环，我们可以通过 arr[i] 的 .length 来获得子数组的长度，因为 arr[i] 的本身就是一个数组。 另一种类型的 JavaScript 循环被称为while循环，因为它规定，当（while）条件为真，循环才会执行，反之不执行。 Math Math.random()用来生成一个在0(包括0)到1(不包括1)之间的随机小数，因此Math.random()可能返回0但绝不会返回1。要生成的随机数是在两个指定的数之间。 用 Math.floor() 向下取整 获得它最近的整数 1Math.floor(Math.random() * 20); 定义一个最小值和一个最大值。 1Math.floor(Math.random() * (max - min + 1)) + min 正则 Regular expressions 正则表达式被用来根据某种匹配模式来寻找strings中的某些单词。 我们可以把这个正则表达式分成几段： / 是这个正则表达式的头部 the 是我们想要匹配的模式 / 是这个正则表达式的尾部 g 代表着 global(全局)，意味着返回所有的匹配而不仅仅是第一个。 i 代表着忽略大小写，意思是当我们寻找匹配的字符串的时候忽略掉字母的大小写。 我们可以在正则表达式中使用特殊选择器来选取特殊类型的值。 特殊选择器中的一种就是数字选择器\d，意思是被用来获取一个字符串的数字.在JavaScript中, 数字选择器类似于: /\d/g。 在选择器后面添加一个加号标记(+)，例如：/\d+/g，它允许这个正则表达式匹配一个或更多数字。尾部的g是’global’的简写，意思是允许这个正则表达式 找到所有的匹配而不是仅仅找到第一个匹配。 我们也可以使用正则表达式选择器 \s 来选择一个字符串中的空白。空白字符有&quot; &quot; (空格符)、\r (回车符)、\n (换行符)、\t (制表符) 和 \f (换页符)。空白正则表达式类似于：/\s+/g 你可以用正则表达式选择器的大写版本 来转化任何匹配。举个例子：\s 匹配任何空白字符，\S 匹配任何非空白字符。 JSON与API JavaScript Object Notation 简称 JSON，它使用JavaScript对象的格式来存储数据。JSON是灵活的，因为它允许数据结构是字符串，数字，布尔值，字符串，和对象的任意组合。 数组中有多个 JSON 对象的时候，对象与对象之间要用逗号隔开。 通过串联起来的点操作符或中括号操作符来访问JSON对象的嵌套属性。因为属性的名字带有空格，请使用中括号操作符来访问属性的值。 JSON对象可以嵌套对象和数组。与访问嵌套对象一样，用中括号操作符同样可以访问嵌套数组。 函数返回的永远是整个对象 使用中括号操作符来访问对象的变量属性 JSON是一种非常简洁的数据格式。它通常表现为了两种形式，一种为单个对象，一种为多个对象 单个对象类似于： 1&#123;name:'盖伦',advantage:'单挑无敌'&#125; 多个对象类似于： 1[&#123;name:'盖伦',advantage:'单挑无敌'&#125;,&#123;name:'诺克',advantage:'上单霸主'&#125;] 每个对象属性和属性值的组合就是我们经常听到的”键值对(key-value pairs)”。 当你需要根据服务器返回的数据来动态改变页面的时候，应用程序接口(API)就派上用场了。API——应用程序接口(Application Programming Interface)是计算机之间相互交流沟通的工具。 许多网站的应用程序接口(API)都是通过一种称为JSON格式的数据来传输的，JSON 是 JavaScript Object Notation的简写。 举例： 从JSON API中获得了数据： 123$.getJSON("/json/cats.json", function(json) &#123; $(".message").html(JSON.stringify(json));&#125;); 把它们展现到我们的HTML页面中吧。 使用.forEach()函数来循环遍历JSON数据写到html变量中。 首先我们定义一个HTML变量，var html = &quot;&quot;; 。 然后，我们使用.forEach()函数来循环遍历JSON数据写到html变量中，最后把html变量显示到我们的页面中。 12345678json.forEach(function(val) &#123; var keys = Object.keys(val); html += "&lt;div class = 'cat'&gt;"; keys.forEach(function(key) &#123; html += "&lt;b&gt;" + key + "&lt;/b&gt;: " + val[key] + "&lt;br&gt;"; &#125;); html += "&lt;/div&gt;&lt;br&gt;";&#125;); 获得的JSON数组中，每个对象都包含了一个以imageLink为键(key)，以猫的图片的url为值(value)的键值对。 遍历,用imageLink的属性来显示img元素的图片。 1html += "&lt;img src = '" + val.imageLink + "'&gt;"; 不想把所有从JSON API中得到的图片都展现出来，可以在遍历之前做一次过滤。把其中 “id” 键的值为1的图片过滤掉。 123json = json.filter(function(val) &#123; return (val.id !== 1);&#125;); 可以通过浏览器navigator获得我们当前所在的位置geolocation。位置的信息包括经度longitude和纬度latitude。 12345if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(function(position) &#123; $("#data").html("latitude: " + position.coords.latitude + "&lt;br&gt;longitude: " + position.coords.longitude); &#125;);&#125; Object对象 可以使用构造函数来创建对象。 构造函数通常使用大写字母开头，以便把自己和其他普通函数区别开。 下面便是一个构造函数： 12345var Car = function() &#123; this.wheels = 4; this.engines = 1; this.seats = 1;&#125;; 在构造函数中，this 指向被此构造函数创建出来的对象 。所以当我们在构造函数中写： 1this.wheels = 4; 创建出来的新对象将带有 wheels 属性，并且赋值为 4. 构造函数描述了它所创建出来的对象。 使用构造函数时，我们通过在它前面使用 new 关键字 来对它进行调用，如下： 1var myCar = new Car(); myCar 现在成为了 Car 的一个实例(instance），它被构造函数描述成下面的样子： 12345&#123; wheels: 4, engines: 1, seats: 1&#125; 要使用 new 关键字去调用构造函数。因为只有这样，Javascript才知道这是要去构造一个新对象 ，并且把构造函数中的 this 指向这个新对象。 当 myCar（即 Car 的一个 实例 ）创建后，他可以像普通对象一样被使用，包括创建、访问、修改它的属性等，就像我们使用其他对象一样。 对象拥有自己的特征，称为属性，对象还有自己的函数，称为方法。 构造函数中，我们使用了 this 指向当前（将要被创建的）对象中的公有属性 。 我们也可以创建私有属性和私有方法，它们两个在对象外部是不可访问的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reeCodeCamp学习笔记（三）]]></title>
      <url>%2FFreeCodeCamplearn3.html</url>
      <content type="text"><![CDATA[FreeCodeCamp学习笔记（三）chrome调试学习elements标签 在chrome浏览器中右击选中Inspect element即可访问elements标签，然后你就可以随便修改元素文本，元素标签和任何其他CSS或者HTML。 这些修改不会自动保存，不能当做IDE或者可以保存内容的编辑器。你可以使用chrome中的’persistent authoring’功能去保存更改。 记住这里层叠，继承和其他CSS规则都可以使用，另外，被覆盖的式样会以穿越文字的横线的形式展示。 需要注意的是现在”树”中看到的代码是当前的HTML，而不是页面加载时的代码。如果你用JavaScript或Jquery来改变页面元素，”树”就会更新。 Padding，border和margin都很容易在右下角的彩色盒子里面检查和编辑。 network标签 network标签页是用来回答’页面中哪个部分最耗时间’或’哪个调用初始化了网络请求’ network仪表盘记录了页面中每个元素加载的详细信息。 每一个请求都记录在network仪表盘的底部日志中 观察底部的线条，你会注意到彩色图案。每一个颜色都代表了请求中的不同类型内容。 线越长代表网络耗时越大，我们最终目标就是缩短线长。如果出现长线条，说明某些内容拖慢了整个网页。 点击请求日志，会看到更加详细的请求信息。 Sources标签 Sources标签页对调试JavaScript帮助很大。项目越大，越难准确找到问题所在。 可以对代码的不同部分设置断点，代码会到此停止执行。 有很多种断点类型可以使用，如一行特定代码，一个DOM事件，XMLHTTP请求或一个JavaScript事件。 设置好断电之后，浏览器在进入这段代码或事件时，会暂停执行。 通过减缓代码执行，我们就有机会仔细观察每一个设置点，准确跟踪页面行为。 一旦断点设置好，我们就可以逐步浏览和检查页面中断点处的代码。 和elements标签一样，可以实时编辑代码观察结果，不过记得在别处保存更改。 Timeline 面板 Timeline 面板可以在应用运行时记录和分析所有行为。此处最适合分析应用性能问题。 就像通过network标签找出时间耗费，通过sources标签找出有问题的代码一样，通过Timeline可以观察到更多详细细节。 使用点击timeline的圆形按钮，你可以记录（捕获）堆栈，js性能，内存和图形绘制(CSS)等信息。 chrome会以小粒度的详细日志来展现这些信息，可以通过很多种形式来查看。 所有这些信息可以帮助你很好地理解浏览器中发生的行为，尤其是发现内存占用比较多的事件。 在加载新页面之前记得先点击’clear’按钮再开始记录。 当记录JS事件时，点击title或左侧的’function call’，会重定向到resource标签，同时定位到函数所在位置的代码行。 Profiles 面板 Profiles 面板可以提供web应用或页面的执行时间和内存，主要是针对运行于页面或app上的JavaScript。 这里可以收集到3种类型的概述信息: CPU profile，HEAP snapshot和HEAP profile。HEAP profiles更多的和内存使用信息相关，CPU profile和JavaScript性能相关。 V8分析器可以帮助定位JavaScript中的性能问题，有助于优化代码。 每一个profile都可以在左侧查看，可以对每个页面采集多个profile。总体而言，profiles标签页非常适合优化代码。 Resources 面板 Resources 面板可以显示已经加载的资源，包括：IndexedDB，Web SQL数据库，local storage，session storage，cookies，Application Cache, 图片, 字体和样式表。 可以在浏览器中查看和修改所有这些信息。 当你进行高级网站构建时，resources 面板可以帮你更好的理解app和页面的实时性要求。 Audit 工具 Audit 工具帮助你逐步改善你的页面。 Audit 工具会自动给你提供改进建议。 Console 面板 Console 面板提供了2个主要功能：在开发过程中记录调试信息和提供一个可以用于和文档、开发工具交互的shell环境。 可以使用标准JS语法和特定控制台命令来查看原始数据和结构化数据。 从API中获取的JSON数据是典型的结构化数据。 信息经常会叠加满屏幕，你可以键入’clear()’来清空屏幕。通过勾选’Preserve Log’可以保存日志。 有几种不同的日志命令，比如console.log()用于基本日志记录，console.error()和colsole.warn()用于一些重要信息。 Console中可以追踪异常（代码出现了问题），甚至可以在出现异常时暂停代码的执行，如果你还记得，这个功能在Source标签页中也有。 复杂度学习 时间复杂度是讨论算法花费多少时间的一种方式。它对于更快的提高精简中的软件的运行速度有着很大的作用。 当你编写代码的时候，你应该要知道这个软件需要花多长时间去执行。没有人想要创造一个由于运行缓慢而让用户觉得沮丧的项目。 时间复杂度相对于一个算法来说，是一个或多个函数的集合。 大O符号专门帮助您识别是算法没有’规模’好，还是在有大量不同的用户，信息，或其他投入量工作下运行良好。 这不符合摩尔定律 - 不管你的电脑有多大有快捷，如果算法是成倍地低效率，它在现实就无法使用。 通过在算法中执行的基本操作（基本操作=一个花费固定时间执行的操作）的数目统计来测量时间复杂度。 时间复杂度由函数T(n)表示。O代表函数，(n)表示作用于元件的数目。 渐进时间复杂度，对于任何的有效输入它可能花费的最长时间，是表达时间复杂度最常见的方式。 当你讨论大0符号,通常指的是最坏的情况。 作为一个经验法则,任何用N ^ 2或其他指数对于多个用户的网站来说都不是好的算法。 1234567891011O(1)——确定一个数字是奇数或偶数。O(1)是一个静态的时间常量,不管有多少信息或有多少用户它都是一样的不改变。O(log N)——发现一个字在字典里(使用二分法检索)。二分法检索是一个典型的“分而治之”的算法。O(N)——看一本书O(N log N)——排序一副扑克牌(使用归并排序)O(N ^ 2)——在你购物车上检查你的购物清单的每一样东西O(∞)-掷硬币,直到它落在头上 计算机安全针对密码的字典攻击。 当创建您的密码，有些网站需要极其特殊和复杂的密码，这实际上是一个也不必要的。 他们想要保护你不受字典攻击的攻击。 字典攻击就是尝试字典里的每一个字词，或者是它自己数据库中的常见词汇和很多人使用过的密码 大多数密码都没有这个简单的，但是，这并不重要。 他们只需要简单的密码就可以攻击巨量的账户。 在创建密码时，你想要使用不同的类型，数字和符号，但是最有效的方法之一是出现一些随机的字母。 网络钓鱼 网络钓鱼，是模仿其他正规站点的网页或者邮件，试图欺骗用户输入自己的个人信息，而它却没有连接到它所模仿的站点。 一般情况下，两种方式来保护免受这些攻击：在地址栏中查看网址，打开一个新的浏览器并转到它所声称的网站。 我们还要学习加密和HTTPS。 如果你是在星巴克试图访问您的银行帐户，您有理由怀疑有人能看到，并采集您的信息。 你会想在网址的开头寻找一个绿色的HTTPS而不是HTTP。 这意味着，你向该网站所发送的密码和其他信息都被加密，只有他们可以根据一串码解开的数据。 一般情况下，只要你显示的是私人或敏感信息，检查一下HTTPS。 其他一些提示：重要账户之间不要使用相同的代码。 如果您使用的网站被黑客侵入，密码再长也没用。 同样，不要下载奇怪的文件。 如果你下载的文件不是像.PDF，txt文件，JPG格式这样常见的文件类型，就要小心了。 你下载的一些文件非常厉害，它们甚至可以在后台运行。 最后，让你的软件更新，特别是联网的软件。 信息泄露的一种方式就是’坏人’发现了旧版本的漏洞并突破了安全系统。 这些漏洞在新版本中已经修复，如果你每个软件都保持更新，你可以避免很多问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FreeCodeCamp学习笔记（二）]]></title>
      <url>%2FFreeCodeCamplearn2.html</url>
      <content type="text"><![CDATA[FreeCodeCamp学习笔记（二）基本概念软件概念 软件是程序或在硬件上运行的程序，写入硬件的代码，两种软件类型是操作系统和应用软件。 有三个主要的操作系统：Windows，Mac和Linux。 应用范围包括所有其他软件，如Web浏览器，游戏，还有像Photoshop，查看邮件，编辑文档的软件等。 CDN 内容传递网络(CDN)是一种分布式服务器（网络），基于用户的地理位置向用户分发网页和其他Web内容，网页和内容分发服务器的起源。 CDN的目标是建立更高质量的网络连接。 CDNs通过为用户和用户目标站点之间建立快速通道或提供更快的建立在其他服务器上的镜像站点来达成目标。 这个概念和这种类型的服务不是创新型的想法，但是它正使互联网更加普及。 网站付费使用CDN服务，而CDN反过来you向因特网提供商付费来使用他们的服务和数据。 谷歌托管库就是一种CDNs – developers.google.com/speed/libraries/#jquery 谷歌托管那些(常用的)库，比起你自己(在自己的服务器上)部署这些库，你的用户就可以更快的访问到它。 有可能的话，用户浏览器甚至会存储已经访问过的网站的缓存。 模拟与数字转换和压缩 一个模拟声波可能看起来像任何东西，例子中它是一条波浪线。 计算机采集和测量很多很多不同的点。把他们转化为数字，这就是所谓的采样。之后，计算机可以使用这些数字，并再次把它们变成声音。 压缩的好处是，它是一个更小的文件：它更容易储存，它更容易发送给其他人，它只是占用更少的空间。 压缩声音的一种常用方法是以更低的频率采样。 另一种方式是，它从一个中点而不是0开始采样，所以所采集的数字更小。 在图像中，它是通过测量一组16个的像素来压缩，而不是独立的。 视频中减掉的部分是你想使用一个高质量的数字文件，但当你在压缩时，你需要决定压缩到何种程度以确保用户仍然有最好的体验。 联网 路由器是连接不同的小范围网络的东西。 12345678910111213141516171819我想打个比方：我是一名教师，我在一所学校工作。假如说我有一个包，并且我需要把它送给我在民政事务处工作的人。我不知道她在哪里，我不知道她的办公室所在地，但我知道她的名字。我找我的秘书，像我的第一台路由器，我说&quot;嘿，我需要找在民政事务处的某某，你能帮帮我吗？&quot;，她会说：&quot;当然，我不知道她的办公室准确位置，但我知道，下一步，我可以找到她所在的区域。&quot;于是，她继续并将其它发送至到民政事务处的秘书，下一个路由器。那秘书不知道我是谁或者我在哪里，但她看到包装上的名称，知道结束位置。我想要去表达的是每个路由器只需要知道自己的小网，就在它旁边的站点。它不必知道整个互联网，但只是它自己的连接。它可以获取信息并说，好吧，我不知道确切位置这回事，但我会在正确的方向传递下去吧。这就是它所需要做的事。 路由器可以是不同的尺寸，不同容量，但他们做的是知道自己的邻居，获得信息，并传递向正确的方向。 路由器甚至不必须有完整的包的信息。 如果一台电脑正试图将信息发送到另一个时，数据可能会在不同的路由器之间分开，但是这没问题。计算机仍然知道如何正确地把信息重新组合到一起。 所发送信息的小碎片被称为数据包。包实际上是一小段二进制代码。 这是一个数据包的样子的示例，一段电流的视觉表示，计算机可以把它转化为1和0的，这就是我们所知道的二进制，可以代表任何数字数据。 这些小数据包通过路由器发送，并且如果一个文件是用一个信息包(发送)太大，它可以被分成帧（较小的小数据包）。帧发送到目的地不必采用相同的路由。 他们可以决定哪个路由是开放的，取其速度最快，而且因为它们具有IP地址，所有的路由器知道从哪里发送。一旦他们到达终点目的地，计算机知道如何把所有的信息重新拼合到一起。 源代码，解释器和编译器 源代码本身是程序员创建的文本文档：他们键入它，它的字母，数字和符号。 如果你把这个给别人，让他们看看在他们的电脑查看这个文档，这没法帮助他们查看电子邮件，它不是一个浏览器，它只是一个文本文档。 计算机必须有一种解释它的东西，并使一些有用的东西可以运行于它。 有两种主要的方法是这样做：无论是由一个解释器或编译器。 每个浏览器都有一个解释器，这就是JavaScript如何被处理的。 其他的语言，像C++，使用编译器。 与解释器不同的是，编译器将其所有的工作都放在了程序员的端上。 他们发送他们的包，他们的产品，它已经被编译，它已经可以在一台机器上运行。 然而，JavaScript，和其他的解释型语言，您只需编写JavaScript，用户端的浏览器有能力解释它所以你不需要编译它。 硬件基础知识硬件组成计算机由4个基本部分组成：输入、输出、CPU（中央处理器）、存储器。 输入是你放入计算机的东西。 输出是你在显示屏上所看见的或在扬声器里所听见的。 CPU代表中央处理单元，并且当我们提到计算机时都能想起它。CPU是实现功能，运行软件的部分，由CPU来操作数据。 存储器是我们存储数据和信息的地方。CPU对存储器具有独占访问权。你无法通过输入和输出来访问内存而不使用CPU。 现在存储器可以分为短期存储器, 称作RAM, 或者是长期存储器. 长期存储器通常是硬盘, 但是也可以是使CD-ROM或者是闪存设备, 或是任何这一类的。 除了这四个基本部分, 我们今天还有另外三样东西要谈论: 主板，扩展槽和电源。 主板是连接这些硬件的东西。当这些数据到处流动试图找出该去哪时, 主板帮助他们导流他们，使他们去向正确的地方 扩展卡是声卡，显卡，这类可以提升用户体验的东西。 电源, 就像他的名字一样, 给我们的计算机提供电力。它通常是一个部件并有一个风扇在上面来帮助它散热。 一个芯片全是由成千上万的晶体管(一种只能是0或1的开关)组成的 所有的这些晶体管塞进了一个芯片里，并且这就是芯片存储信息的方式。 在一个芯片上集成的晶体管数量决定了芯片的大小和速度 摩尔定律是观察到自从1965年芯片上的晶体管数量每两年增加一倍的一种规律。 二进制码是一种非常常见的计算机语言，它只能是1或0，也是on(开)或关，1代表on(开)，0代表off(关)。 数据数据大小 最小的单位我们称之为1比特(bit)。比特(bit)只能是0或1, 也就是回到我们一直在学习的二进制。 字节, 很常见, 8比特(bit)。很多东西都可以用二个字节来表示。 下一步是KB, 1024个字节, 或者8192个比特(bit). 之后是MB, 1024个字节的2次方。 之后就是GB了, 1024个字节的3次方； TB, 1024个字节的4次方, 和PB, 1024个字节的5次方。 数据的速率 数据速率不同于数据大小, 通常是计算每秒多少比特, 而大小是计算有多少比特。 一旦我们涉及到指数级，数据速率的表示就有了很大的不同 怎么讨论数据速率取决于我们在讨论的东西。 在音频下载中，我们使用KB/s 网速，我们使用MB/s。如果你看到你的网速有多少多少比特每秒，记住它永远比按你提到数据大小时的字节小8倍。 网络中, 我们用GB/s (十亿比特每秒!)。 这里主要选取方式是速度是按比特来计算而大小是按字节来计算。 超级计算机 一种使用一种叫做并行处理的技术同理用很多CPU处理同一问题的计算机。 服务器 服务器拥有并访问大量的数据或程序。 工作站 一种和个人电脑非常相似的计算机, 但是更耗能且贵的多。 微控制器 一种可能你汽车里都有的计算机，它非常擅长处理小型的特定的任务但是不可以像个人计算机那样操作和使用。 主板的构成是处理器和内存之间的桥梁-如果它不这样做，它就不是一个主板。但是大多数主板要比这个功能多的多。主要是它们有扩展槽和接口。 扩展槽使你可以任意插入提高计算机性能的东西，而不需要让中央处理器负担更多。 举个例子，显卡和声卡可以提供更好的声音和更出色的显示效果从而显著提升用户体验，却不会拖慢电脑。 网卡也可以插进扩展槽。 PC和扩展卡在笔记本上很常见，并且扩展卡因为他们尺寸很小被合并到了主板上。 在电脑上，你会知道有一个地方链接USB，电源接口，SD卡，以太网，甚至是一个音频插孔来通过耳机听声音。它们都是接口，主板上一个可以连接外源到CPU来获取或者给予信息的地方。 数据网络三种类型：局域网(LAN)，广域网(WAN)，虚拟专用网(VPN)。 局域网就像是一小组计算机连接在了一起。局域网最重要的是这些计算机离得很近。 广域网是两个，三个或者更多的局域网长距离的连接起来。 你也许认为他们通过因特网(Internet)相连接，对于VPN来说(虚拟专用网，设计上和广域网相似)，你是对的。 一个广域网通常租用来自因特网公司的电缆来创建连接。 因特网(Internet)的第一部分：因特网是如何工作的。 IP地址：你可能已经习惯了每个设备都有它自己的IP地址，就像一个房子有它自己的地址一样。 如果一个设备没有IP地址因特网不能向它分发数据。 不止设备有，猫(modem)和路由器(router)也有，数据传输路上的每一步都有。 IP地址由位置所决定，起始于5个大型国际地区。 从左到右，数字意味着你的位置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法JavaScript学习(一)]]></title>
      <url>%2Fjs-algorithms-1.html</url>
      <content type="text"><![CDATA[数据结构与算法JavaScript学习(一)数组常用数组方法 push方法，能把元素添加到数组的末尾 unshift方法，可直接把数值插入到数组首位 pop方法，删除数组里靠后的元素 shift方法，删除数组的第一个元素 splice方法，通过指定位置/索引，删除或增加相应位置和数量的元素 number.splice(5,3)删除从数组索引5开始3个元素 number.splice(5,0,2,3,4)从数组索引5开始增加3个元素2,3,4 合并 concat方法，合并数组，可迭代数组，把每个元素加入到最终数组 迭代器函数 every方法，迭代数组中的每个元素，直到返回false some方法，迭代数组中的每个元素，直到返回true forEach方法，迭代整个数组 map方法，遍历数组，得到新数组 filter方法，遍历数组，返回新数组，返回的数组由使函数返回true的元素组成 reduce方法，接受一个函数作为参数，函数有四个参数：previousValue, currentValue, index, array.函数返回一个将被叠加到累加器的值，方法停止执行返回累加器 排序 reverse方法，将数组元素反序输出 sort方法，排序，把元素默认成字符串进行相互比较 搜索 indexOf方法，返回与参数匹配的第一个元素的索引 lastIndexOf方法，返回与参数匹配的最后一个元素的索引 输出字符串 toString方法，把数组里所有元素输出为一个字符串 join方法，用不同分隔符把元素隔开 栈常用方法 push(element(s)),添加一个或几个新元素到栈顶 pop(),移除栈顶的元素，同时返回被移除的元素 peek(),返回栈顶的元素，不对栈做修改 isEmpty(),看栈是否为空，空返回true，否则返回false clear(),移除栈里的所有元素 size(),返回栈里元素的个数 完整实例ES5实现： 123456789101112131415161718192021222324252627function Stack() &#123; let items = []; this.push = function(element)&#123; items.push(element); &#125;; this.pop = function()&#123; return items.pop(); &#125;; this.peek = function()&#123; return items[items.length-1]; &#125;; this.isEmpty = function()&#123; return items.length == 0; &#125;; this.size = function()&#123; return items.length; &#125;; this.clear = function()&#123; items = []; &#125;; this.print = function()&#123; console.log(items.toString()); &#125;; this.toString = function()&#123; return items.toString(); &#125;;&#125; ES6语法： 1234567891011121314151617181920212223242526272829class Stack &#123; constructor () &#123; this.items = []; &#125; push(element)&#123; this.items.push(element); &#125; pop()&#123; return this.items.pop(); &#125; peek()&#123; return this.items[this.items.length-1]; &#125; isEmpty()&#123; return this.items.length == 0; &#125; size()&#123; return this.items.length; &#125; clear()&#123; this.items = []; &#125; print()&#123; console.log(this.toString()); &#125; toString()&#123; return this.items.toString(); &#125;&#125; 队列常用方法 enqueue(element(s)),向队列尾部添加一个或多个新的项 dequeue(),移除队列的第一项，并返回移除的元素 front(),返回队列第一个元素，不做任何修改 isEmpty(),判断是否为空，空返回true，否则返回false size(),返回队列包含的元素个数 完整实例ES5实现： 123456789101112131415161718192021222324function Queue() &#123; let items = []; this.enqueue = function(element)&#123; items.push(element); &#125;; this.dequeue = function()&#123; return items.shift(); &#125;; this.front = function()&#123; return items[0]; &#125;; this.isEmpty = function()&#123; return items.length == 0; &#125;; this.clear = function()&#123; items = []; &#125;; this.size = function()&#123; return items.length; &#125;; this.print = function()&#123; console.log(items.toString()); &#125;;&#125; ES6语法： 1234567891011121314151617181920212223242526272829class Queue &#123; constructor () &#123; this.items = []; &#125; enqueue(element)&#123; this.items.push(element); &#125; dequeue()&#123; return this.items.shift(); &#125; front()&#123; return this.items[0]; &#125; isEmpty()&#123; return this.items.length == 0; &#125; size()&#123; return this.items.length; &#125; clear()&#123; this.items = []; &#125; print()&#123; console.log(this.toString()); &#125; toString()&#123; return this.items.toString(); &#125;&#125; 排序算法冒泡排序12345678910111213141516171819202122232425262728293031function ArrayList()&#123; var array=[]; this.insert=function(item)&#123; array.push(item); &#125;; this.toString=function()&#123; return array.join(); &#125;; //交换两个数 var swap=function(index1,index2)&#123; var aux=array[index1]; array[index1]=array[index2]; array[index2]=aux; &#125;; //改进冒泡排序 this.modifiedBubbleSort=function()&#123; var length=array.length; for(var i=0;i&lt;length;i++)&#123;//控制数组经过多少轮排序 for(var j=0;j&lt;length-1-i;i++)&#123;//从第一位迭代至倒数第二位 if(array[j]&gt;array[j+1])&#123;//当前项和下一项比较 swap(j,j+1); &#125; &#125; &#125; &#125;;&#125; 选择排序12345678910111213141516171819202122232425262728293031323334function ArrayList()&#123; var array=[]; this.insert=function(item)&#123; array.push(item); &#125;; this.toString=function()&#123; return array.join(); &#125;; //交换两个数 var swap=function(index1,index2)&#123; var aux=array[index1]; array[index1]=array[index2]; array[index2]=aux; &#125;; this.selectionSort=function()&#123; var length=array.length,indexMin; for(var i=0;i&lt;length-1;i++)&#123;//迭代数组 indexMin=i;//数组第一个为最小值 for(var j=i;j&lt;length;j++)&#123;//从当前i至数组结束 if(array[indexMin]&gt;array[j])&#123; indexMin=j; &#125; &#125; if(i!==indexMin)&#123; swap(i,indexMin); &#125; &#125; &#125;;&#125; 插入排序12345678910111213141516171819202122232425function ArrayList()&#123; var array=[]; this.insert=function(item)&#123; array.push(item); &#125;; this.toString=function()&#123; return array.join(); &#125;; this.insertionSort=function()&#123; var length=array.length,j,temp; for (var i = 1; i &lt; length; i++) &#123;//迭代数组，默认第一项排序 j=i;//初始化一个辅助变量 temp=array[i]; while (j&gt;0&amp;&amp;array[j-1]&gt;temp) &#123;//找到位置，前面的值比此值大 array[j]=array[j-1];//交换 j--;//j减少 &#125; array[j]=temp;//赋值 &#125; &#125;;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function ArrayList()&#123; var array=[]; this.insert=function(item)&#123; array.push(item); &#125;; this.toString=function()&#123; return array.join(); &#125;; //归并排序:分治递归算法 this.mergeSort=function()&#123; array=mergeSortRec(array); &#125;; //将大数组分成小数组 var mergeSortRec=function (array) &#123; var length=array.length; if (length===1) &#123; return array; &#125; var mid=Math.floor(length/2), left=array.slice(0,mmid), right=array.slice(mid,length); return merge(mergeSortRec(left),mergeSortRec(right)); &#125;; //合并小数组 var merge=function(left,right)&#123; var result=[],il=0,ir=0; while (il&lt;left.length &amp;&amp; ir&lt;right.length) &#123; if (left[il]&lt;right[ir]) &#123; result.push(left[il++]); &#125;else &#123; result.push(right[ir++]); &#125; &#125; while (il&lt;left.length) &#123; result.push(left[il++]); &#125; while (il&lt;right.length) &#123; result.push(right[ir++]); &#125; return result; &#125;;&#125; 快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function ArrayList()&#123; var array=[]; this.insert=function(item)&#123; array.push(item); &#125;; this.toString=function()&#123; return array.join(); &#125;; //快速排序:分治递归 this.quickSort=function () &#123; quick(array,0,array.length-1); &#125;; //快排 var quick=function (array,left,right) &#123; var index; if (array.length&gt;1) &#123; index=partition(array,left,right); if (left&lt;index-1) &#123; quick(array,left,index-1); &#125; if (index&lt;right) &#123; quick(array,index,right); &#125; &#125; &#125;; //划分过程 var partition=function(array,left,right)&#123; var pivot=array[Math.floor((right+left)/2)],i=left,j=right;//选主元 while (i&lt;=j) &#123; while (array[i]&lt;pivot) &#123; i++; &#125; while (array[j]&gt;pivot) &#123; j--; &#125; if (i&lt;=j) &#123; swapQuickStort(array,i,j); i++; j--; &#125; &#125; return i; &#125;； //交换数组元素 var swapQuickStort=function (array,index1,index2) &#123; var aux=array[index1]; array[index1]=array[index2]; array[index2]=aux; &#125;;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用JavaScript做一个AI五子棋]]></title>
      <url>%2Fjs-chess.html</url>
      <content type="text"><![CDATA[使用JavaScript做一个AI五子棋实现步骤： canvas画图 js实现棋盘 js实现棋子 棋盘落子 canvas画图12345678910&lt;canvas id="chess" width="450px" height="450px"&gt;&lt;/canvas&gt;canvas &#123; display: block; margin: 50px auto; box-shadow: -2px -2px 2px #efefef, 5px 5px 5px #b9b9b9;&#125;var chess = document.getElementById('chess');var context = chess.getContext('2d'); js实现棋盘12345678910var drawChessBoard = function() &#123; for (var i = 0; i &lt; 15; i++) &#123; context.moveTo(15 + i * 30, 15); context.lineTo(15 + i * 30, 435); context.stroke(); context.moveTo(15, 15 + i * 30); context.lineTo(435, 15 + i * 30); context.stroke(); &#125;&#125; js实现棋子12345678910111213141516171819var oneStep = function(i, j, me) &#123; //画圆 context.beginPath(); context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI); context.closePath(); //渐变 var gradient = context.createRadialGradient(15 + i * 30 + 2, 15 + j * 30 - 2, 13, 15 + i * 30 + 2, 15 + j * 30 - 2, 0); if (me) &#123; gradient.addColorStop(0, "#0a0a0a"); gradient.addColorStop(1, "#636766"); &#125;else&#123; gradient.addColorStop(0, "#d1d1d1"); gradient.addColorStop(1, "#f9f9f9"); &#125; context.fillStyle = gradient; context.fill();&#125; 落子12345678910111213141516171819202122232425262728293031chess.onclick = function(e) &#123; var x = e.offsetX; var y = e.offsetY; //向下取整算出索引 var i = Math.floor(x / 30); var j = Math.floor(y / 30); if (chessBoard[i][j]==0) &#123; oneStep(i, j, me); if (me) &#123; chessBoard[i][j]==1; &#125;else&#123; chessBoard[i][j]==2; &#125; //me轮流取反 me = !me; &#125;&#125;//默认黑子var me = true;//存储棋盘落子情况var chessBoard=[];for (var i = 0; i &lt; 15; i++) &#123; chessBoard[i]=[]; for (var j = 0; i &lt; 15; j++) &#123; chessBoard[i][j]=0; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5存储初探]]></title>
      <url>%2Fhtml-store.html</url>
      <content type="text"><![CDATA[HTML5存储初探常见存储： Cookies localStorage &amp;&amp; sessionStorage indexedDB application cache 其它客户端存储： userData 只有IE支持（IE5.0 … 9.0） google Gears chrome (12.0后放弃支持) 引擎：64SQLite 需要用户授权 CookiesCookies是一种能够让网站服务器把少量数据储存到客户端的硬盘或内存，或是从客户端的硬盘读取数据的一种技术。Cookies是当你浏览某网站时，由Web服务器置于你硬盘上的一个非常小的文本文件，它可以记录你的用户ID、密码、浏览过的网页、停留的时间等信息。 当你再次来到该网站时，网站通过读取Cookies，得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等等 Cookies文件是在无声无息中伴随浏览器进入我们本地硬盘的，当我们浏览某个站点时，该站点很可能将记录我们隐私的cookies文件上传到本地硬盘。 H5存储解决了cookie的问题 解决cookie总数和单个大小的限制(4k 4095B) 解决请求头常带存储信息的问题 解决关系型存储的问题 跨浏览器 本地存储( localStorage &amp;&amp; sessionStorage) 图片不经常更改，不过如果图片bash64比较大的话，会比较浪费资源） 常用属性和方法： 123456localStorage.key(i).length.getItem(&quot;&lt;key&gt;&quot;).setItem(&quot;&lt;key&gt;&quot;,&quot;&lt;value&gt;&quot;).removeItem(&quot;&lt;key&gt;&quot;).clear() 使用注意事项： 使用前先判断浏览器是否支持（浏览器开启无痕模式后不能用，有的可读但不可写，所以不能用 if(window.localStorage){}来做兼容处理，先set，然后再捕获异常） 写数据时，要异常处理，避免抛出容量错误 避免将敏感信息写入localStorage 注意key的唯一性，会被覆盖 使用场景： 利用本地数据，减少网络传输 弱网络环境下，高延迟，低带宽，尽量把数据本地化 H5本地存储的使用限制 需要添加存储更新策略和过期控制 子域名之间不能共享存储数据 超出存储后如何存储(LRU,FIFO) --&gt; LRU (Least Recently Used) FIFO (先入先出) server端如何取到数据（请求参数） localStorage优点： 存储大小达5M 兼容性好，功能强大 应用范围广 IndexedDB 定义 一种能在浏览器中持久存储结构化数据的数据库，并为web应用提供了丰富的查询能力。 浏览器支持 chromw11+，FF4+，IE10+，移动端支持弱 存储结构 按域名分配独立空间，一个域名下可创建多个数据库，一个DB可以创建多个对象储存空间（表），一个对象存储空间可以创建多个对象数据。 功能 增删改 事务 游标 索引 注：w3c已不在维护Web SQL. 离线缓存（application cache） 离线缓存（application cache）：让web应用在离线情况下继续使用，通过manifest文件指明要缓存的资源 检测是否在线：navigator.onLine 原理（如图）：读取离线缓存，同时检查manifest文件，有更新时更新文件和缓存 appcache使用和更新 使用：创建manifest文件 修改资源文件，必须通过修改manifest文件来更新被缓存的文件列表 优点 完全离线 资源被缓存，加载更快 降低server负载 缺陷 含有manifest属性的当前页一定会被缓存 更新依赖manifest文件，更新后需要再次刷新 更新是全局性的，无法单点更新 对于链接的参数变化敏感，不同的参数视为不同的文件 占用资源 更新内容会在下次生效 浏览器支持：IE8-不支持 适用场景 单地址的页面（无参数） 对实时性要求不高的业务 离线webapp 总结 H5存储优势： 存储空间大 接口丰富 数据相对安全 关系型 省流量 H5存储劣势： 浏览器兼容( localStorage 和 app cache 主流浏览器都兼容的不错 ) 同源策略( localStorage 不可以跨子域，manifest 所引用的文件必须在同一个域名下面 ) 脚本控制( 只能在浏览器端存放；服务器端想拿到数据，只能通过请求 ) 更新策略（不像cookie可以设置过期时间；比如localStorage永不过期，必须自己写一套更新机制 )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FreeCodeCamp学习笔记(一)]]></title>
      <url>%2Ffcc-note-1.html</url>
      <content type="text"><![CDATA[FreeCodeCamp学习笔记(一)HTML学习 a标签用#做占位符 img标签里应加alt属性，为了盲人朋友 123&lt;a href="#"&gt; &lt;img class="smaller-image thick-green-border" alt="A cute orange cat lying on its back" src="/images/relaxing-cat.jpg"&gt;&lt;/a&gt; input标签加placeholder做占位符提示，在需要设置必填项的时候加required属性 1&lt;input type="text" placeholder="cat photo URL" required&gt; 单选和复选按钮应加入到label标签里，name属性名应一致，checked为默认选中 12345&lt;label&gt;&lt;input type="radio" name="indoor-outdoor" checked&gt; Indoor&lt;/label&gt;&lt;label&gt;&lt;input type="radio" name="indoor-outdoor"&gt; Outdoor&lt;/label&gt;&lt;label&gt;&lt;input type="checkbox" name="personality" checked&gt; Loving&lt;/label&gt;&lt;label&gt;&lt;input type="checkbox" name="personality"&gt; Lazy&lt;/label&gt;&lt;label&gt;&lt;input type="checkbox" name="personality"&gt; Energetic&lt;/label&gt; 盒子模型有三个影响HTML元素布局的重要属性：padding(内边距)、margin(外边距)、border(边框)。 元素的 padding 控制元素内容 content和元素边框 border 之间的距离。 当加大 padding, 将扩大元素内容和元素边框的距离。 元素的外边距 margin 控制元素边框 border 和元素实际所占空间的距离。 当增大 margin 时，将会增加元素边框和元素实际所占空间之间的距离。 如果你将一个元素的 margin 设置为负值，元素将会变大。 CSS学习浏览器读取 CSS 的顺序是从上到下，这意味着，在发生冲突时，浏览器会使用最后的 CSS 声明。但是如果设置id， id 属性总是具有更高的优先级。 很多情况下，你会使用 CSS 库，这些库可能会意外覆盖掉你自己的 CSS。所以当你需要确保某元素具有指定的 CSS 时，你可以使用 !important. rgb颜色设置0 是 hex code（十六进制编码）中最小的一个，它代表颜色的完全缺失。 F 是 hex code（十六进制编码）中最大的一个，它代表最大可能的亮度。 16 个值和 6 个位置意味着我们有 16 的 6 次方，或者说超过 1600 万种可能的颜色. Hex code 遵循 red-green-blue（红-绿-蓝），或者叫 rgb 格式。hex code 中的前两位表示颜色中红色的数量，第三四位代表绿色的数量，第五六位代表蓝色的数量。 jquery学习jQuery通过选择器来选择一个元素的，然后操作元素做些改变。 要让所有的按钮做弹回效果，只要把这段代码写在1$(document).ready(function() &#123;&#125;); 里面，然后1$("button").addClass("animated bounce"); 你可以通过jQuery的addClass()方法给元素添加class,也可以通过jQueryremoveClass()方法去掉元素上的class。 1$("#target2").removeClass("btn-default"); jQuery有一个叫做.css()的方法能让你改变元素的CSS样式。 1$("#target1").css("color", "blue"); jQuery有一个.prop()的方法让你来调整元素的属性 1$("button").prop("disabled", true); jQuery的.html()方法可以添加HTML标签和文字到元素，而元素之前的内容都会被方法的内容所替换掉。 我们是通过em[emphasize]标签来重写和强调标题文本的： 1$("h3").html("&lt;em&gt;jQuery Playground&lt;/em&gt;"); jQuery 还有一个类似的方法叫.text()，它只能改变文本但不能修改标记。换句话说，这个方法只会把传进来的任何东西(包括标记)当成文本来显示。 jQuery有一个appendTo()方法可以把选中的元素加到其他元素中。 1$("#target4").appendTo("#left-well"); jQuery的clone()方法可以拷贝元素。方法链function chaining，使用起来很方便 1$("#target2").clone().appendTo("#right-well"); 每个HTML元素根据继承属性都有父parent元素,jQuery有一个方法叫parent()，它允许你访问指定元素的父元素 1$("#left-well").parent().css("background-color", "blue") 许多HTML元素都有children(子元素)，每个子元素都从父元素那里继承了一些属性jQuery有一个方法叫children()，它允许你访问指定元素的子元素。 1$("#left-well").children().css("color", "blue") jQuery 用CSS选择器来选取元素，target:nth-child(n) CSS选择器允许你按照索引顺序(从1开始)选择目标元素的所有子元素。 1$(".target:nth-child(3)").addClass("animated bounce"); 获取class为target且索引为奇数的所有元素，并给他们添加class。 1$(".target:odd").addClass("animated shake"); jQuery里的索引是从0开始的，也就是说：:odd 选择第2、4、6个元素，因为target#2(索引为1)，target#4(索引为3)，target6(索引为5)。获取class为target且索引为偶数的所有元素，并给他们添加class。1$(".target:even").addClass("animated shake"); 让整个body都有淡出效果(fadeOut)： 1$("body").addClass("animated fadeOut"); $(document).ready(),这个函数中的代码只会在我们的页面加载时候运行一次，确保执行js之前页面所有的dom已经准备就绪。 增加一个click事件,通过点击事件来更改文本。 123$("#getMessage").on("click", function()&#123; $(".message").html("Here is the message");&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3实现3D魔方]]></title>
      <url>%2Fcss-3d.html</url>
      <content type="text"><![CDATA[CSS3实现3D魔方实现思路 写出基础HTML框架 基本CSS样式，初始化 CSS实现魔方的各个面：外轮廓和内盒子 CSS3实现魔方表面的3D位置 CSS3实现旋转 第一步：HTML结构六个面类似如下结构 12345678910111213141516&lt;h1&gt;3D魔方&lt;/h1&gt;&lt;div class="view"&gt; &lt;div class="box"&gt; &lt;div class="red-surfaces"&gt; &lt;div id="one"&gt;&lt;/div&gt; &lt;div id="two"&gt;&lt;/div&gt; &lt;div id="three"&gt;&lt;/div&gt; &lt;div id="four"&gt;&lt;/div&gt; &lt;div id="five"&gt;&lt;/div&gt; &lt;div id="six"&gt;&lt;/div&gt; &lt;div id="seven"&gt;&lt;/div&gt; &lt;div id="eight"&gt;&lt;/div&gt; &lt;div id="nine"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 第二步：CSS初始化1234567891011121314151617181920212223* &#123; margin: 0px; padding: 0px;&#125;body &#123; min-height: 600px; height: 100%&#125;body h1 &#123; margin-top: 50px; text-align: center;&#125;.view &#123; margin: -60px auto; width: 800px; height: 800px; position: relative; border-radius: 20px; -webkit-transform: scale(0.7);&#125; 第三步：CSS实现魔方的各个面-外轮廓和内盒子外轮廓样式 12345678910111213.red-surfaces,.blue-surfaces,.green-surfaces,.white-surfaces,.orange-surfaces,.yellow-surfaces &#123; height: 330px; width: 330px; position: absolute; border-radius: 5px; top: 235px; left: 235px;&#125; 内盒子样式 123456789101112.red-surfaces&gt;div,.blue-surfaces&gt;div,.green-surfaces&gt;div,.white-surfaces&gt;div,.orange-surfaces&gt;div,.yellow-surfaces&gt;div &#123; height: 100px; width: 100px; display: inline-block; border: 5px solid rgba(170, 170, 170, 0.9); position: absolute;&#125; 内盒子颜色 : 六面 123.red-surfaces&gt;div &#123; background-color: rgba(255, 0, 0, 0.8);&#125; 内盒子定位 ：九个小块 1234#one &#123; left: 0px; top: 0px;&#125; 第四步：CSS3实现魔方表面的3D位置六个表面不同角度设置 123.red-surfaces &#123; -webkit-transform: rotateX(-90deg) translateZ(165px);&#125; 第五步：CSS3实现旋转keyframe定义 ：animation name规定需要绑定到选择器的keyframe名称 duration规定完成动画所花费的时间，以秒或毫秒计 timing-function规定动画的速度曲线 delay规定在动画开始之前的延迟 iteration-count规定动画应该播放的次数 direction规定是否应该轮流反向播放动画 123.box&#123; -webkit-animation:BoxRotate 3s ease-in-out infinite;&#125; 动画旋转基准 : transform-origin 123.box&#123; -webkit-transform-origin: 400px 400px 200px;&#125; 3D实现：transform-style 123.box&#123; -webkit-transform-style: preserve-3d;&#125; keyframe定义旋转 1234567891011121314151617@-webkit-keyframes BoxRotate &#123; 16% &#123; -webkit-transform: rotateY(-90deg) rotateZ(135deg); &#125; 33% &#123; -webkit-transform: rotateY(-90deg) rotateX(135deg); &#125; 50% &#123; -webkit-transform: rotateY(225deg) rotateZ(135deg); &#125; 66% &#123; -webkit-transform: rotateY(135deg) rotateX(135deg); &#125; 83% &#123; -webkit-transform: rotateX(135deg); &#125;&#125; 总结CSS3也可以实现js实现的动画，而且还减少资源消耗，要熟练掌握新特性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kali linux 安装指南]]></title>
      <url>%2Fkali-linux-install.html</url>
      <content type="text"><![CDATA[kali linux 安装指南 Kali Linux是基于Debian的Linux发行版， 设计用于数字取证和渗透测试。Kali Linux预装了许多渗透测试软件，包括nmap (端口扫描器)、Wireshark (数据包分析器)、John the Ripper (密码破解器),以及Aircrack-ng (一应用于对无线局域网进行渗透测试的软件).用户可通过硬盘、live CD或live USB运行Kali Linux。Metasploit的Metasploit Framework支持Kali Linux，Metasploit一套针对远程主机进行开发和执行Exploit代码的工具。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook. –[百度百科] 安装步骤下载kali linux 官网 U盘刻录镜像刻录U盘工具：Win32 Disk Imager 这个工具刻录的镜像比较完整，可直接用U盘启动，比软碟通要好。 安装 刻录U盘后重启电脑，不需要用EasyBCD。 重启电脑后进入bios，选择U盘启动 进入镜像，选择Graphical install选项，当然选择install也是一样的 安装语言、地区、键盘 无法挂载光盘解决：拔下U盘再插上，选择是继续 网络设备固件缺失：直接选择否继续 设置主机名和密码：默认用户名：root 密码：toor 磁盘分区（最重要一部分），这一部分是很重要的一步，一定要注意看清，选对，再操作。 选择手动 选择我们准备好要安装kali的那个分区 分配分区: /boot:启动分区 / :根分区 /home:用户目录 /tmp:临时文件 /usr:文件系统 /var:可变数据目录 /opt:附加应用程序 swap:交换分区 一般分/boot、/、/home、swap 分区方案关键点： 大数据库一般要加大/usr挂载点 多用户、下载类、多存储文件等要加大/home挂载点 文件小，用户多要注意/tmp和/var挂载点大小 选择“分区设定结束并将修改写入磁盘”继续 开始格式化并写入磁盘，这个过程可能有点长，请耐心等待 网络镜像 写入引导（很重要一步）:一定选是，是个坑 安装完成 安装之后 更新软件源 修改sources.list文件：/etc/apt/sources.list 然后选择添加适合自己较快的源（可自由选择） 保存之后： apt-get update #刷新系统 apt-get dist-upgrade #安装更新 kali-linux安装中文输入法 apt-get install fcitx-table-wbpy ttf-wqy-microhei ttf-wqy-zenhei #拼音五笔 安装gnome管理软件 apt-get install gnome-tweak-tool 安装新立德 apt-get install synaptic 安装解压缩软件 apt-get install file-roller 安装smplayer视频播放器 apt-get install smplayer 安装多窗口终端 apt-get install terminator 安装VMware和VirtualBox 使用及相关系统渗透测试笔记：使用渗透工具进行测试 BackBox：黑客工具箱 Parrot Security os：本人用的最炫的一个系统，安装也简便，工具很强大，但是系统内部文件跟常规系统不太一样，适合对linux熟悉的人员使用 Cyborg Hawk：工具最多的一个系统，但是全英文，不支持中文，对英语水平要求很高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Google Hack]]></title>
      <url>%2Fgoogle-hack.html</url>
      <content type="text"><![CDATA[Google Hack 这些命令在Google搜索引擎中才能使用 中文引号“ ”在搜索关键字时，加上中文的“ ”号，你就能精确的只搜“ ”里面的文字了。 在搜索词后面加上“site:网站名”举个例子：就如搜索 白帽 site:sina.com，那么就能搜索在新浪（sina.com）这个域名下的，有关“白帽”的信息了。搜索出的结果均为新浪网中，与白帽有关的网页 “-”就一个减号，在输入搜索词的后面，空格后加上一个减号。在减号后面输入你想过滤的东西，比如你想搜姚明，但又不想看他与篮球有关的东西，那么你只需要这样姚明 -篮球进行搜索就可以得出姚明与篮球无关的信息了。 * 号在搜索词前面加上该符号，就可以搜索出与*号后面相关的词语的内容，如你输入*伟，那么出来的结果都会是XX伟，而不会是伟XX的内容。 filetype爱在网上找资料的人都有很难找到想要的东西，要么名字对格式不对，要么格式对，内容不对。这里的filetype就可以准确的搜索出某个关键字下，你想要的文件名。如搜索数学 filetype：pdf，就会出来与数学有关的所有pdf文件。 info:url在搜索栏中输入这个，就会出来被搜索网址的所有信息。 intitle:标题在搜索词前输入这个命令，那么就会搜出网页中是以搜索词为标题的网页。 inurl:网址输入网址后，是在搜索的结果中，把包含了URL的结果页面返回（也就是在结果中找有多少是你的网址的内容），如：inurl:baidu.com site:www.sina.com，则会搜索出新浪网中所有包含了baidu.com 网址的网页。 link:url这个是独立使用的，输入这个之后，可以搜索出所有与这个网页有关联的网页。也就是我们平时进入网页后，可以在网页底部看到的合作网站。通过这个命令，我们可以不用进入网站就可以查出这个网站与那些网站合作了，明里暗里的都能看到哦。 location：区域这个命令是为了精确区域而设计的，如你只想查深圳的女子大学的网页，那么就可以这样进行查找：女子大学 location：ShenZhen这样就会出来深圳区域所有的女子大学相关网页了，而不会把其它地区的女子大学的也搞过来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS学习笔记]]></title>
      <url>%2Fcss-note.html</url>
      <content type="text"><![CDATA[CSS学习笔记CSS Positioning(定位)CSS定位属性允许你为一个元素定位。它也可以将一个元素放在另一个元素后面，并指定一个元素的内容太大时，应该发生什么。元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法 Static 定位HTML元素的默认值，即没有定位，元素出现在正常的流中。 静态定位的元素不会受到top, bottom, left, right影响。 Fixed 定位元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。 Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。 Relative 定位相对定位元素的定位是相对其正常位置。 可以移动的相对定位元素的内容和相互重叠的元素，它原本所占的空间不会改变。相对定位元素经常被用来作为绝对定位元素的容器块。 Absolute 定位绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。 Absolutely定位使元素的位置与文档流无关，因此不占据空间。 Absolutely定位的元素和其他元素重叠。 重叠的元素元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素。 z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面），一个元素可以有正数或负数的堆叠顺序。 CSS Float(浮动)CSS 的Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。Float（浮动），往往是用于图像，但它在布局时一样非常有用。 元素怎样浮动元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动元素之后的元素将围绕它。 浮动元素之前的元素将不会受到影响。 清除浮动 - 使用 clear元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素。 常见CSS布局双飞翼布局 圣杯布局 流式布局 CSS3 模块CSS3被拆分为”模块”。旧规范已拆分成小块，还增加了新的。 一些最重要CSS3模块如下： 选择器 盒模型 背景和边框 文字特效 2D/3D转换 动画 多列布局 用户界面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习笔记]]></title>
      <url>%2Fhtml-note.html</url>
      <content type="text"><![CDATA[HTML学习笔记HTML结构及常用元素123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;可见文本...&lt;/body&gt;&lt;/html&gt; 123456&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt; 123456789101112131415161718192021222324252627282930&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt;&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt;&lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本）普通的链接：&lt;a href="http://www.example.com/"&gt;链接文本&lt;/a&gt;图像链接： &lt;a href="http://www.example.com/"&gt;&lt;img src="URL" alt="替换文本"&gt;&lt;/a&gt;邮件链接： &lt;a href="mailto:webmaster@example.com"&gt;发送e-mail&lt;/a&gt;书签：&lt;a id="tips"&gt;提示部分&lt;/a&gt;&lt;a href="#tips"&gt;跳到提示部分&lt;/a&gt;&lt;img src="URL" alt="替换文本" height="42" width="42"&gt; HTML实例代码12&lt;div&gt;文档中的块级元素&lt;/div&gt;&lt;span&gt;文档中的内联元素&lt;/span&gt; 1234&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt;&lt;/ul&gt; 1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; 12345678910&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 1&lt;iframe src="demo_iframe.htm"&gt;&lt;/iframe&gt; 123456789101112131415&lt;form action="demo_form.php" method="post/get"&gt;&lt;input type="text" name="email" size="40" maxlength="50"&gt;&lt;input type="password"&gt;&lt;input type="checkbox" checked="checked"&gt;&lt;input type="radio" checked="checked"&gt;&lt;input type="submit" value="Send"&gt;&lt;input type="reset"&gt;&lt;input type="hidden"&gt;&lt;select&gt;&lt;option&gt;苹果&lt;/option&gt;&lt;option selected="selected"&gt;香蕉&lt;/option&gt;&lt;option&gt;樱桃&lt;/option&gt;&lt;/select&gt;&lt;textarea name="comment" rows="60" cols="20"&gt;&lt;/textarea&gt;&lt;/form&gt; HTML5 中的一些有趣的新特性用于绘画的 canvas 元素 用于媒介回放的 video 和 audio 元素 对本地离线存储的更好的支持 新的特殊内容元素，比如 article、footer、header、nav、section 新的表单控件，比如 calendar、date、time、email、url、search IE9 以下版本浏览器兼容HTML5的方法：使用菜鸟教程的静态资源的html5shiv包123&lt;!--[if lt IE9]&gt;&lt;script src="http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 载入后，初始化新标签的CSS：123article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123; display:block&#125; html5shiv.js 引用代码必须放在&lt;head&gt;元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。 字符实体HTML 中的预留字符必须被替换为字符实体。 一些在键盘上找不到的字符也可以使用字符实体来替换。 HTML 中的常用字符实体是： 不间断空格 &amp;nbsp; 大于 &amp;rt 小于 &amp;lt; 引号 &amp;quot; 版权 &copy;`&amp;#169; 注册商标 &amp;reg; &amp;#174; 商标 &amp;trade; URL - 统一资源定位器Web浏览器通过URL从Web服务器请求页面。当您点击html页面中的某个链接时，对应的 &lt;a&gt;标签指向万维网上的一个地址。 一个统一资源定位器(URL) 用于定位万维网上的文档。 语法规则: scheme://host.domain:port/path/filename 说明: scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 runoob.com :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SEO学习笔记]]></title>
      <url>%2Fseo-note.html</url>
      <content type="text"><![CDATA[SEO学习笔记 搜索引擎工作原理 SEO简介： Search Engine Optimization 搜索引擎优化 白帽SEO 灰帽SEO 白帽SEO（内容上的SEO）： 网站标题、关键字、描述 网站内容优化 Robot.txt文件 网站地图 增加外链引用 SEO注意要点： 结构布局优化：用扁平化结构（层次结构超过三层小蜘蛛就不愿意爬了） 控制首页链接数量（中小网站100以内，页面导航、底部导航、锚文字链接等） 扁平化的目录层次（小蜘蛛跳转3次可以到达网站内任何一个内页，网站的设计主页、栏目、内容页，不要用纵线性的结构） 导航seo优化（头部、底部、内容部分，主导航、副导航、分类导航，尽量用文字，面包屑导航，在每个网站上留下面包屑，使用户可以了解网站组织形式，放于正文的左上方） 内容页面的布局细节 左面正文，右面热门文章、相关文章，下面是版权信息及链接，栏目排布：首页123456789下拉选择最赞） 网站的加载速度会影响小蜘蛛的爬行，页面最好不要超过100k 网页代码优化（语义化代码） title标题：强调重点 meta keywords关键词：列举几个关键词/简洁高效词语 meta description网页描述：高度概括网页的内容 以上信息不要堆积、重复 有利搜索引擎 a：访问外部链接时要加上title 说明123456789102. h1：搜索引擎外认为 h1 最重要，使用 css 调整，网页正文标题用 h1，副标题用 h2，其他不要乱用 h 标签3. br 用于文本间的换行，用在 p 内，也可以用 ```&lt;p&gt;&lt;br/&gt;&lt;/p&gt; ```表示空行4. caption：表格标题5. img：使用 title、alt 说明6. ```&lt;strong&gt;&lt;em&gt;```表示强调，```&lt;em&gt;```的权重仅次于```&lt;strong&gt;```，如果只想表示加粗斜体，建议使用```&lt;b&gt;&lt;i&gt;```,表示强调则使用```&lt;strong&gt;&lt;em&gt; 重要内容 HTML 代码放在最前面（使用 css 改变布局） 重要内容不要用 JS 输出（搜索引擎看不懂 JS） 尽量少使用 iframe 框架（搜索引擎不喜欢） 谨慎使用display:none（搜索引擎会过滤掉其内容，设置 z-index/text-index 代替） 精简代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提升效率]]></title>
      <url>%2Fenhance-efficiency.html</url>
      <content type="text"><![CDATA[提升效率 在前进的路上，放弃那些次要的、可有可无的东西，获取真正重要、有意义的价值，让自己更加认同自己的付出和努力方向，这才是时间管理的本质和最大意义所在。 必须学会说“不”说“不”其实是个非常艰难的事情，可是如果不说no，那么就很难专心地应对真正重要的任务。因为有太多看起来不错的机会、看上去不能拒绝的要求、事成后有利的图景，以及无法拒绝的人情世故，诱惑着你答应下来。 其实工作越久，你就越会发现，真正的牛人，往往就牛在敢于放弃上。所谓的战略化决策，不仅仅是指战略高度的选择，也指战略高度的放弃。刚开始放弃的时候会很难受，这是多年形成的习惯和求全责备的心态发出的尖叫和抗议。可是时间久了才发现：不重要的事情真做不完也不会死，倒是重要的事情老拖着不做往往会后果比较严重。 必须学会说yes对我而言，如果想要找时间完成真正重要的事情，那么就先答应下来，再商量个相对宽裕的时间。将这些定下来之后，我总能想出方法，排除万难去实践。 无论是写小说、开公众号、参加考试，都可以遵循这个套路。牺牲掉部分娱乐、睡眠、社交，甚至是和家人团聚的时间，会非常适合短期内的明确目标，并督促你用冲刺的方式完成。 如果一件事情并不重要，那么就明确地拒绝；如果很重要，就大胆地接受。你不会因为说“不”损失多少，也不会因为应承去做却没有做好而损失很多。真正的损失是在我们说“这事儿很好，我再想想”中发生的。 金钱换时间以前没有孩子的时候，我习惯利用整块时间写作，写作进入状态也非常缓慢，必须要在阳光充足的某个角落坐下，泡杯咖啡，看看新闻，再慢慢进入状态。 现在可用的业余时间往往是零散的，如果不能抓住零散时间进行思考和打草稿，那就更没有时间了。为了能更好地抓住这些碎片时间，我添置了更多的电子设备，例如静音且无须插电源的平板电脑，它能让我更好地利用孩子入睡后的时间。再比如我打破了从前不下载App的习惯，安装了多个阅读、记录、拍照笔记类的App，方便自己在零碎时间里能随时把读到的、想到的、看到的、诱发灵感的材料都尽快地收纳进来。 找到时间后，就是筹划和管理时间了。 关掉提醒，高效专注地工作要想工作有效，就必须运用整块的时间。如果将时间分割开来零星使用，纵然时间总和相同，但其效果与整块运用时间的效果却差距很大。比如我以前工作时常要写一些措辞讲究的英文邮件，如果能够聚精会神地写，再加上润色，十几分钟就能完成。可是我总会忍不住一边写一边去看看什么人又说了什么话，有时还会因为查某个单词去逛下红迪网。 后来实在忙起来了，任凭各种新信息提醒也不去查看，等到某个任务告一段落，再统一查看和回复，既保证了效率，又不至于错过什么。仅这一项小小的改变，就大大提高了我的工作效率。 减少选项，设置优先级选项越少，时间越多。一个比较经典的时间管理方法是：每天只选择1～3件事情去做，并辅以不懈地追求。你的本能不会喜欢这样的限制，可是这种方法有利于排列真正重要的事情，比起事无巨细地齐头并进，能让工作更为出色。 提前把你想到的写下来当事情一旦多了杂了，脑子就明显不够用。我经常发现，哪怕是小事，如果写下来就会遵守；不写，无论在脑子里想多久，一被打扰就会忘掉。提前计划的目的其实不是为了“计划”，而是为了更重视时间的流向，知道时间都花到哪里去了。 如果不是很清晰地知道要做什么，就容易碰到什么是什么。于是哪件事情先找上来就先处理了，就好比我特别反感邮箱，因为邮件不停地进来，叮的一声响。只要邮箱的叮声不关，我就永远干不了该干的事情，会一直挂在邮箱上回复邮件，而且要一会儿回邮件，一会儿写报告，一会儿又查数据。数据查到一半叮的一声邮件又进来了，说到了另一件事，再去查……忙了一上午，几件重要的大事却一件都没干。 先把所有需要完成的事列出来，然后对大任务进行分解，分解成小一些的子任务，再对任务进行排序。排序时最艰难的步骤就是决定放弃或者推迟哪些东西。 找到适合自己的好方法开始时间管理的时候，大家都会热衷于搜罗和学习各种方法。比如有一种著名的战拖策略叫作“吃掉那只青蛙”，鼓励大家给最重要、最困难的任务以第一优先权。但是我在实践之后，却发现这个方法极其不适合我。因为如果一上来就强迫自己完成最艰巨的任务，我反而会容易知难而退，会造成各种拖延。所以我摸索出的合适自己的方法是先完成最简单、最有兴趣的工作，通过这些初级工作渐入佳境，等效率上来了，再去啃“坚硬的骨头”。 说到这里，时间管理却还不能结束。桥本和彦曾经说过，“没有体现结果的时间管理就不能称之为时间管理”，因此定期对时间管理的成就和不足之处进行反思，就有非常重要的意义。 坚持时间管理最大的挑战就在于：即便你用最高科技的工具，按照最合理的科学方法、符合生物钟的方法规划好了时间，然后恪守，一天下来有很大的收获，你的内心也在呼唤你歪倒在沙发上刷手机、追美剧、和朋友瞎聊。 为了战胜无时不在的诱惑，就需要时不时地重温一下目标，配合着各种短期、中期、长期的目标，时间管理上也应相应配合着进行松弛有度的分布。任何时间管理和战拖秘诀都离不开恒心，但是生活必须要张弛有度。 如果是学生为了考GRE，那么两个月的短期突击式的冲刺，要比断断续续地复习一年有效；而大考完毕，可以有一小段时间让大脑放松下，以便进入下一阶段的目标。 一个人如果长期无目标地疲劳战斗，那么时间管理便会沦为空谈，你依旧会身心俱疲且内心无比迷茫，那样的话还不如好好歇着。 当然，如果把时间管理放到整个人生来看，有些人喜欢有计划、高产高效的生活，也有人喜欢随性自由的节奏。这些都没有问题，你尽可以按自己的喜好选择自己喜欢的方式。不过要记住，每种选择都意味着相应的放弃，只要回过头时不会患得患失就好。 对很多人而言，时间管理也是一种成就。他们对时间管理的追求，就是对成就感的追求，这也是他们进行时间管理的最大动力。 如果是这种情况，那么拥有一个能完成后打钩的to-dolist（待办事项列表）或者任务工作本、相关任务管理App，让这种成就可视化，就是很好的选择。 对我个人而言，时间管理的最大成功，不是达成了什么了不起的大成就，而是让自己能更明晰时间的去向、对事物的价值度有所衡量，并通过“管理时间”这一具体行动，让自己不再盲目焦虑。 总结在前进的路上，放弃那些次要的、可有可无的东西，获取真正重要、有意义的价值，让自己更加认同自己的付出和努力方向，这才是时间管理的本质和最大意义所在。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习新技术建议]]></title>
      <url>%2Flearn-method.html</url>
      <content type="text"><![CDATA[学习新技术建议 我们生活在一个振奋人心的时代。我们可以越来越方便廉价地获得大量学习资源。这些资源的传播载体由最初的教室被变成了博客，技术论坛等。坐拥如此众多的学习资源，我们没有任何理由不去好好利用。随之而来的问题便是如何在这知识的海洋中选择自己的前进方向。尽管我的建议主要涉及的是软件开发方面，但是这些原则在其他领域也同样适用。 克服惯性万事开头难，克服惯性是学习新技术的第一步。举个日常生活中惯性存在的简单栗子，当我们看电视的时候会因为遥控器不在身边而懒得换台。幸运的是有很多的小技巧可以调动我们的积极性，帮助我们克服惯性。对于我来说，微习惯是一个很好用的小技巧。与其被手头的任务吓到，不如将任务细分为一个个具体的微任务，然后挑选其中的一个开始做起。就“拿到遥控器”这个例子来说，首先扭动你的脚趾，向前伸出，然后推动整个人离开沙发。下一步，身体滑到地上，用脚拿到遥控器，然后起身。通过完成一个个的微任务，你会发现自己克服了惯性，并且这项任务不再显得难以完成。这个方法可以被应用到学习新技能的过程中。关键就是将大块任务细分为微任务。 关注大牛学习新技能的第一步是明确要学什么。它可以是任何你有激情去学，并且想深入学习的一些东西。这种原始的学习欲望非常重要，这种欲望可以在你的学习低潮期给你提供动力。你想学的或许是一门新的编程语言、应用框架或者是新的工具，一旦你确定了想要的是什么，就立刻去收集相应的优秀群体所做的一些优质的工作成果。这些可以从YouTube、Vimeo、HackerNews、各种博客，甚至是你的微博好友那里获取。关注别人做了些什么可以给你强大的信心，让你觉得 “You can do it, too!” 建立知识网当你对自己要学习的东西建立了信心之后，接下来要做的就是做一块海绵，然后开始疯狂地吸收知识。从Google搜索关键词“beginner tutorials”开始吧，搜索一些跟你要学习的知识相关的入门教程。如你所知，Nettuts+上面有成千上百的各种教程供你选择，StackOverflow上面也有很多学习资源。此外，Quora也是一些不错的选择。通过浏览这些网上的资源之后，如果想要集中精力学习某一方面，这时就需要阅读一些相关的书籍了，个人推荐在Amazon上面寻找一些评分较高的专业书籍来提高自己。 多听多看随着你对技术的深入挖掘，你可能会想利用更多其他形式的学习资料，比如podcasts，screencasts等等。我的建议是多用 iTunesU，这上面有很多很专业的知识可以让你对于特定的领域进行深入的探索。 可以看一些免费的会议视频材料，比如YouTube上面的Google IO，以及Confreaks！ 行动起来现在你已经看了一波又一波的教程以及视频资料，并且对于想学的技术已经有了一个相当深入的了解，接下来做些什么呢？没错，是时候理论联系实际了，实践是检验真理的唯一标准。 用你所掌握的技术做一个个人的小项目，设计一些简单的功能并且实现他们。毫无疑问，你会遇到很多的绊脚石，当遇到它们的时候，在StackOverflow或者Google上面搜索之，解决之。你已经踏上一条成为某一领域专家的旅程，遇到的困难挫折越多，你会变得越睿智。有句老话说得好，“专家是犯错最多的人”，这意味着他们尝试了很多疯狂的事情来探索这门技术的极限，最后，对于这门技术是如何运作的就可以知根知底。拥有这种洞察力之后，他们便可以随心所欲的运用这项技术去按照自己的意愿完成想做的事情（当然，是做好的事情）。 写博客在你进行你的探险之旅的时候，实时记录下你的成长以及犯下的错误大有裨益。在技术领域，博客是最简单易得并且受欢迎的表达载体。当你准备落笔的时候，你会强迫自己整理思路，并且对积累下来的零散的知识片段进行结构梳理。说不定，通过互联网的分享，你的经历和分享会给别人的成长带来帮助。 如果你想走的更远（比如想像Nettuts+上面的职业作者一样），你也可以制作属于自己的screencasts。总的来说，写博客能够提升你的个人沟通能力，这与你学到的技术同样重要。 感受技术的脉搏社交网络已经广泛应用于人们的日常交流以及发现新鲜事物。Twitter和Facebook是信息的主要来源，与此同时，有很多的网站提供更专注的资讯，如前面提到过的Quora网站，这上面有很多涉及面很广的一些话题供人们评论。在这上面可以找到很多知名大牛的建议以及观点。 浏览StackOverflow上面的众多话题是一个很有意思的过程，你可以看到他人如何探索某种技术的极限。事实上，在人们利用技术做一些疯狂的甚至是荒诞的事情的时候，技术也随之不断的成熟起来。 因此，如果你想要感受到技术的脉搏，并且想确认它是否值得学下去，在StackOverflow上面试着搜索一些话题，看看这个讨论社区的广度与深度。最值得看的是投票最多以及热门话题。你也可以尝试在GitHub上面进行搜索。 参加聚会以及会议尽管社交网络很棒，但是没有任何事物可以取代面对面的交流。在你住的附近参加一些小组聚会，在这里你可以找到志同道合的伙伴。你可以知道他人在做的一些有趣的项目，同时也可以在他人的帮助下解决一些自己遇到的难题！同样的，技术会议对于分享经验以及增长技术大有帮助！ 拥抱 GitHubGitHub是全世界开源项目的标志性建筑物。它是知识以及优质代码的宝库。当你对某项技术自我感觉良好的时候，下一步便是在GitHub中浏览寻找有趣的项目。阅读开源代码，尽可能多的阅读。这样做的话，你能够学到很多东西，比如说： 如何管理规模较大的项目 项目中应用的有趣的库 代码规范以及代码全局设计 文档风格 测试规范 解决诡异问题的方法，以及发现项目中有问题的地方 所有的这些知识都在等待着你去挖掘。有趣的是，这些知识的通过一个简单的标签就可以得到，那就是“好奇心”。 专注学习如果你担心上述的学习过程太迟缓，那么你也可以尝试一下快速学习模式。你或许听说过“24小时学会某某某”，但是这种方式不是我所推荐的。我认为更合理的是用几周的时间去学习。你可以尝试一下类似“七周学会七种语言”或者是“七周学会七种数据库”等学习方法。尽管这些讲的是语言以及数据库方面的学习，但是你在学习其他技术的时候也可以运用这种思维。 有一个不太相同的学习风格是“困难学习模式”，这种观点的前提是没有人可以真正掌握一门技术，除非每天都练习。所以，想要成为专家，你就需要不停地进行练习。异曲同工的是你可以查看Katas 和 Koans，他鼓励的使用你学的知识来解决问题。这些可以让你更好地入门以及接受那些陌生的概念，勇敢走出自己的舒适区，开始学习新知识！ 学习一门交叉的技能编程是一项左脑的运动，它利用的是大脑的分析能力，一步一步地寻找解决问题的方法。为了发挥右脑的功能，你可以尝试从事一些创造性的活动，比如说画画、3D建模、折纸、乐器甚至是制作家庭相册等。事实上，编程同样需要大量的创造力。或许你曾经遇到过类似的事情，你在睡梦中找到了问题的解决方案。这是因为你的右脑处理问题的方式很不同，它可以从各种地方获得信息。敏捷开发权威人士Andy Hunt就这个话题写了一本书《程序员的思维修炼》。如果你想点燃你的每一个神经元，建议你开始学习一门交叉的技能。 不害怕探索陌生程序语言接触新专案或是转换工作跑道时，都有可能需要学习全然陌生的程序语言，许多人对此感到害怕，甚至未尝试就先放弃。其中，跳脱舒适圈的恐惧往往多于学习程序，会担心是否无法重现过去工作的好表现，甚至因此怀疑自身能力。 不论是多厉害的工程师，一定都有起点，就像打造Microsoft Windows基础的微软资深工程师Dave Cutler为文组出身，没受过正式电脑科学教育，比起同辈花更多时间在错误中学习。 在这之中，最重要的两个关键为具备「成长心态」（growth-mindset）而非「固守心态」（fixed-mindset），以及「乐于学习」（optimize for learning）的态度。 学习陌生程序语言这项关键能力会越练越上手，并让你在学习过程中成为更好的程序设计师。 精通Debug为什麽程序跑出来和我预期的不一样？是许多工程师会遇到的问题。Debug能力往往是影响工程师是否能顺利完成专案的关键因素，却被大部分人低估。 Debug的系统性思考如下： 先假设造成bug的可能原因。 若假设为真，界定此假设可能导致的结果。 试著检视是否有和这些结果衝突的现象。 若有衝突表示假设错误，要重複上述思考过程。 由此可知，想加快Debug速度，要提升「提出假设」和「检视假设」的能力。假设能力可随著Debug经验的累积而提升，检视能力则需加强善用检测工具的技能。 在此过程，必须先假设所有东西都是可检视的，并找出可用来检测或加快检测速度的工具或机制，千万不要只用自己熟悉的工具。 开发节省时间的工具减少时间做那些电脑就可做的工作，例如开发节省时间的工具和使工作流程自动化。 曾负责Facebook软件基础建设团队的软件工程师Bobby Johnson，带领该团队从6人成长至超过1百人。他观察到，团队中表现出色的人多数写了许多工具，这些看似和绩效无直接相关的工具开发时间可能佔三分之一的工作时间，却因此大大提升工作效率，其中包含用来部署程序、监测系统，以及其他可节省时间的工具。 优化重复性工作的速度软件工程师每天可能要搜寻、浏览函数定义很多次，善用键盘快捷键可省下可观的时间。 例如，每次搜寻需花12秒，类似的步骤每天要重複20次，若用快捷键可将搜寻时间缩短到2秒，一年下来即省了40个小时。其他状况如每次Debug都需要在不同装置测试，除了要分别打开app，还要设定测试情境，这时候就可以思考如何加快这类重複性工作的速度。 发展系统性思考模式写完程序码、让程序可运作仅是冰山一角，要产出真正有价值的程序，必须从程序本身提升到整个系统来思考。 你的程序和其他程序库以及其他人写的功能是否相容？ 程序是否测试完成，并确保其他成员可执行你写的这些功能？ 部署你的程序需要改变哪些生产环境？ 新程序对其他正在运作的系统是否有负面影响？ 客户和使用者的新程序使用情况是否如预期？ 新程序是否达到公司期待的效果？ 固定型思维模式改变的四个方法。对称赞和成功进行认知转换第一，对称赞和成功进行认知转换。转换对称赞的认知，我的意思是当你获得错误方式的称赞时，将它们转换为有利成长型思维模式的称赞。因此如果有人说“哇，你的工作做得真好，你太聪明了！”，你可以将它转换为“耶!太好了，我在这个项目中真努力！”。你没必要大声地喊出来！但是认知转换能让你提高寻求挑战和付出努力的主动性！ 你可以在成功或成就中采用相同的方式。当一些事情进行的顺利的时候，不要觉得“当然会做的很好因为我聪明啊”，而是想“我在这个项目中采用了一个有效的方法！我应该更多地去应用这个方法”。 转换对失败的认知第二，转换对失败的认知。当然这个方法的另一面也非常有效。固定型思维模式和成长型思维模式的很大一部分是你怎样应对失败。当你面对挫折或者没有得到你想要的结果时，你的内心戏是怎么样的？如果你觉得“可能我确实不适合这份工作”，这时应该用红色小旗做标识。与此相反，你应该问问你从你的失败中得到了什么或者哪种学习方式你需要改变。这个方法听起来很平常，但是真的很有用。 为挑战庆幸第三，为挑战庆幸。当你必须竞争的时候你是什么样的反应？试着为此感到庆幸。这是我在Recurse Center工作时始终坚持的习惯。一些人会坐在我旁边说：“我遇到一个奇葩的Python bug（叹气）”。 我说：“太好了，我就喜欢奇葩的python bugs！”。首先，让我们来说说，有一点是清楚的——当你遇到一个奇葩的bug，相对于bug本身更重要的是，这说明你找到了一些可以通过努力获得成就感的事情，这些事情是你可遇不可求的。 像我提到的一样，在Recurse Center没有交付日期，没有任务分配，因此这种心态是无需付出任何代价的。我一般会说“你可以花一天时间在Flask（python的一个框架）上追踪这个bug，多好啊！”现在，在Dropbox（一种云存储服务）上，我们有一个产品要开发，有交付日期和相应用户。我不能总是一味地为花一天时间来为追踪bug感到高兴。因此，我对身处有交付日期的现实中的人们深感同情。然而，如果我必须修复一个漏洞，我承认bug的存在不利于我对漏洞的修复。但是在没有交付日期的情况下，你仍然可以采用我的态度。 关注过程第四，关注过程。跟很多人一样，我同一些优秀的工程师一起工作。有时，我会试着用不合理的方式修复一些棘手的bug，但是有些人能够以正确的方式修复。在这种情况下，我会习惯性地问他们怎么做到的。尤其当我刚用Dropbox的时候，他们的回答会很有启发性。有时，他们回答的一些信息来自于我根本不知道的知识中。现在，我在这里待得久了，经常看到和别人技术和方法上的不同，或者发现一些自己的方式之所以不能成功的细节。 这种方法对于总是觉得：“这个人能解决这个bug一定是个天才！”的一类人，是长期最有效的。 总结掌握一门新技术振奋人心，这是一项影响你思维的新的体验。但是首先，你必须克服你的惯性，一旦你做到了，你便开启了从web的每个角落学习知识的旅程。我希望上面讲的十点能够给你的旅程带来一些帮助或启发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Linux问题的解决办法]]></title>
      <url>%2Flinux-question-solve.html</url>
      <content type="text"><![CDATA[关于Linux问题的解决办法 我安装win10和Debian系的linux双系统，以这个双系统为基础，解决linux问题。 关于win10更新之后，重新启动没有windows的引导的问题解决方法： 进入Linux操作系统，打开命令行 输入 su 切换root用户 输入apt-get updateupdate-grub 重启系统，出现windows的引导 关于当前使用用户不在sudoers文件中，无法使用sudo命令的问题解决方法： 切换到超级用户root su 查看/etc/sudoers权限，可以看到当前权限为440 ls -all /etc/sudoers出现下列： -r–r—– 1 root root 744 6月 8 10:29 /etc/sudoers 更改权限为777 chmod 777 /etc/sudoers 编辑/etc/sudoers vi /etc/sudoers 在root ALL=(ALL:ALL) ALL 下面添加一行 user ALL=(ALL)ALL 然后保存退出。 解释：第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明user可以在此主机上执行后面的命令。第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。最后一个ALL当然就是指命令名了。 把/etc/sudoers权限改回440 chmod 440 /etc/sudoers 操作完成,可以使用sudo命令 Linux中GRUB引导故障的修复解决方法： 需要用usb做个Debian的系统安装盘 从usb启动，进入debian的修复模式，进入终端 fdisk -l 查看分区情况 需要识别出分区与原文件系统的挂接关系 /dev/sda7 swp /dev/sda8 / /dev/sda9 /home /dev/sda10 /boot 把与目录/对应的分区/dev/sda8挂在/mnt上，把与目录home对应的分区/dev/sda9挂在/mnt/home上， 把/dev挂在/mnt/dev上 输入命令chroot /mnt 输入命令grub-install /dev/sda 重启，出现引导 进入系统, su update-grub 重启，进入系统]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[格局]]></title>
      <url>%2Fsetup.html</url>
      <content type="text"><![CDATA[格局格局就是指一个人的眼光、胸襟、胆识、心理等要素的内在布局。 如果把人生当做一盘棋，那么人生的结局就由这盘棋的格局决定。想要赢得人生这盘棋的胜利，关键在于把握住棋局。 一个人的格局大小与否说实话是很难定义的，但是一个人是否拥有广阔胸襟却对自己以及周围的人影响很大。 胸怀的大小会让你看见不一样的世界，会让你寻找到生活中旁人看不到的风景。 你是什么样的人，你就会和什么样的人交朋友，这句话还是很有道理的。 做人智商高不高没关系，情商高不高也问题不大，但做人的格局一定要大，说白了，你可以不聪明，也可以不懂交际，但一定要大气。 “再大的烙饼也大不过烙它的锅。”你可以烙出大饼来，但是你烙出的饼再大，它也得受烙它的那口锅的限制。 我们所希望的未来就好像这张大饼一样，是否能烙出满意的“大饼”，完全取决于烙它的那口“锅”。 这就是所谓的“格局”。 有一个乞丐，整天在街上乞讨，对路上衣着光鲜的人毫无感觉，却嫉妒比自己乞讨得多的乞丐，这人估计一直就是个乞丐了。 一个人的发展往往受局限，其实“局限”就是格局太小，为其所限。谋大事者必要布大局，对于人生这盘棋来说，我们首先要学习的不是技巧，而是布局。 大格局，即以大视角切入人生，力求站得更高、看得更远、做得更大。大格局决定着事情发展的方向，掌控了大格局，也就掌控了局势。 为什么别人会有大格局？有的人说，站的高才能看的远；也有人说，欲为大树，莫于草争；有人说，格局即大局观了；有人说，大格局就是大胸怀；还有人说，大格局就是看的远。 不过，事物也本无对错之分。站的高，确实是能够看的远。有大格局的人确实也不会斤斤计较，有大格局的也往往看的远。 很多人认为，后天的成就主要靠自己。虽说，一个人是否有作为，后天的努力占了很大的部分。但是，先天性的环境因素占了很大一部分。 试想，如果你从小生活在一个资源匮乏的环境，眼界往往不够开阔，总是为基本的生活而操劳，哪来格局。但是，即便是有的人生活在资源充沛的环境，也见过大世面，也并不一定有大格局。但是，可以肯定的是格局受环境影响很大。而我们大部分人，其实总体生活的环境本质差异并非太大。 眼光 眼光是指在某一时刻，对某领域趋势准确预测的能力。 第一，你能不能看到别人看不到的东西，能不能够透过表象看到事物发展的本质。 第二，对于事物的评判已经有自己的标准，并能够极为准确根据现在对未来进行预测。 第三，是你知道这些道理之后，自己能不能做得到。 人贵有自知之明，知道什么可为和不可为。若不可为，怎样做才能可为，那何时可为。 胸襟人的胸怀很有意思，有大的追求，大的愿望，就会有大的忍耐，大的包容，大的视野，大的宽容，这就叫大胸怀吧。 如果你的想法是追求一个具体的、很小的事情，你得不到它会很生气；如果你想要的是别人没有的，是很大的东西，很远的东西，你就会变得能够理解很多，包容很多，能够承受痛苦，甚至伤害你的事情你也能够包容。这是一个正循环。 如果一点点挫折就让你爬不起来，如果一两句坏话、就让你不能释怀，如果动不动就讨厌人，憎恨人，那格局就太小了。 做人有多大气，就会有多成功。因为胸襟，才是成功者的标志。 胆识曾有企业家这样说，“如果是现在把我归零，我仍然可以再来一次”。然而，史玉柱则是在资产为负数，甚至负得还很多的时候站了起来。 应该说，他是中国迄今为止唯一经历了“大起——大落——又大起”这样一个完整过程的著名企业家，他创造了一个中国乃至全球经济史上绝无仅有的传奇故事。 当巨人大厦倒塌，讨债人蜂拥而至之时，史玉柱庄重承诺：“欠老百姓的钱一定要还。”也正是出于这种“还债”的动力，史玉柱终于东山再起，且赚钱后的第一件事情就是还债。 行军作战需要胆识，成功创业更需要胆识，只有想法却不敢去实现终究不会成功，莽撞行事也只会导致失败，有勇有谋才能事半功倍。 总结拥有大格局者： 有开阔的心胸 没有因环境的不利而妄自菲薄 更没有因为能力的不足而自暴自弃。 拥有小格局者： 往往会因为生活的不如意而怨天尤人 因为一点小的挫折就一筹莫展 看待问题的时候常常是一叶障目不见泰山，成为碌碌无为的人。局不够大，人生成就再高也有限！ 所以说，格局真的决定人生层次。 格局在岳飞那里就是八千里路云和月，三千功名尘与土的壮烈； 格局在马致远那里却是小桥流水人家，断肠人在天涯的孤旅； 格局在苏轼那里就是我欲乘风归去，又恐琼楼玉宇，高处不胜寒的的寂寞； 格局在柳永那里就是杨柳岸，晓风残月，衣带渐宽终不悔，为伊消得人憔悴的烟花柳巷而已。 一个人有多大的格局才有多大的胸襟。格局是一种眼界，是一种大情怀，海纳百川才能有容乃大。 什么样的眼界和胸襟才能看到更远的风景，站在高处，整座城市不过就是几座楼房，在飞机上从云端俯瞰城市，城市也就变成了盆景。 放下你的浮躁，放下你的懒惰，放下你的三分钟热度，放空你禁不住诱惑的大脑，放开你容易被任何事物吸引的眼睛，放淡你什么都想聊两句八卦的嘴巴，静下心来好好做你该做的事，该好好努力了!有时候真的努力后，你会发现自己要比想象的优秀很多。 世上除了生死，其它都是小事。不管遇到了什么烦心事，都不要自己为难自己;无论今天发生多么糟糕的事，都不要对生活失望，因为还有明天。 有目标的人在奔跑，没目标的人在流浪，因为不知道要去哪里! 有目标的人在感恩，没目标的人在报怨，因为觉得全世界都欠他的! 有目标的人睡不着，没目标的人睡不醒，因为不知道起来去干嘛! 生命只有走出来的精彩，没有等待出来的辉煌! 如果，感到此时的自己很辛苦，那告诉自己：容易走的都是下坡路!坚持住，因为你正在走上坡路，走过去，你就一定会有进步。 如果，你正在埋怨命运不眷顾，那请记住：命，是失败者的借口;运，是成功者的谦词。命虽由天定，但埋怨，只是一种懦弱的表现;努力，才是人生的态度!相信你可以! 记住一句话：越努力，越幸运。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用GitHub和hexo搭建个人主站]]></title>
      <url>%2Fhexo-blog-install.html</url>
      <content type="text"><![CDATA[用GitHub和hexo搭建个人主站前言作为一个程序员，拥有一个自己的博客，平时记录一下，分享点技术文章，是很有必要的。建立博客的通常渠道包括： 在博客平台上注册，比如 博客园、CSDN、新浪博客 等。 利用博客框架搭建，如 WordPress、Jekyll、hexo 等。 自己用代码写一个。 其中，第一种最简单，也最受限，说不定还会被删帖删号。第二种稍复杂，另外需要自己找部署的服务器，但可定制化较高，是很多程序员的选择。最后一种，是在重复造轮子，不过从另一个方面来看，倒是锻炼编程能力的好方式。 下面我们就来看下第二种搭建博客的方式： github＋hexo 建立你的第一个博客 部署博客及更新博文 安装自己喜欢的主题 购买并绑定域名 第一步：github＋hexo 建立你的第一个博客下面先介绍为何选择 GitHubPages 和 Hexo 来搭建博客，然后介绍搭建博客的详细过程。 Why GitHub Pages and Hexo 因为 GitHub 的存在，我们得以简单快速地搭建个人博客。 GitHub，是一个代码托管网站和社交编程网站。这里聚集了世界上各路技术牛叉的大牛，和最优秀的代码库。 GitHub Pages，是用来托管 GitHub 上静态网页的免费站点，那 GitHub Pages具体有哪些功能呢： 有 300M 免费空间，资料自己管理，保存可靠； 享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多； 可以使用很多现成的博客框架，搭建过程简单快速。 Hexo 是一个简单、快速、强大的静态博客框架,出自台湾大学生 tommy351 之手。我也试过使用 Jekyll搭建个人博客的过程，确实要繁琐许多。相比之下 Hexo 更轻便更快捷，下面是其官网强调的四大特点： 极速生成静态页面 一键部署博客 丰富的插件支持 支持 Markdown 大家对 GitHub Pages 和 Hexo 有了一定的了解，下面进入正题。 创建 GitHub Pages 仓库注册 GitHub访问 GitHub，注册十分简单，一定要记住注册时使用的邮箱，因为 GitHub 上很多通知都是通过邮箱的。申请成功后，在 GitHub 官网上登录，并验证邮箱即可。 在 GitHub 上建立仓库与 GitHub 建立好连接之后，就可以方便的使用它提供的 Pages 服务，GitHub Pages 分两种，一种是用你的 GitHub 用户名建立的 username.github.io 这样的用户&amp;组织站点，另一种是依附项目的 Pages。 想建立个人博客是用的第一种，形如 【username.github.io】 这样的可访问的站点，每个用户名下面只能建立一个。建立仓库的方法参照github官网的教程。 搭建HEXO所需环境安装软件Node.js下载完成后根据提示一步一步安装就好，这个没有什么需要特别说明的。 GitHub for Windows下载并安装这个软件，一直点击下一步即可 git 使用GitHub for Windows登录GitHub配置 SSH 我们如何让本地 git 项目与远程的 GitHub 建立联系呢？方法是用 SSH。 打开命令行，输入以下命令：ssh -T git@github.com 如果是下面之类的反馈（或者显示 Hi xxx）：The authenticity of host &#39;github.com &#39; can&#39;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)?不用紧张，输入 yes 之后就配置成功了。 Hexo 安装Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。 打开git bash命令行，输入命令：npm install -g hexo 创建 Hexo 博客Hexo 初始化Hexo 的初始化命令：hexo init 部署成功之后，用hexo生成静态页面，输入命令：hexo generate或者hexo g也可以 此时在本地进行预览（在刚才创建的blog文件夹里），输入命令：hexo server或者hexo s 此时打开浏览器，在浏览器地址栏输入 http://localhost:4000/ （默认端口为4000）, 便可以看到最原始的博客了。 以后发表博文想先预览，也可以通过 hexo server 在本地先跑起来，看看效果。 在 Git Shell 中按 Ctrl+c 可以停止该服务。 配置Github建立Repository：建立与你用户名对应的仓库，仓库名必须为【username.github.io】，这是固定写法 然后建立关系，找到之前建立的blog文件夹，之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要修改_config.yml文件，来建立关联，使用notepad++打开_config.yml文件 翻到最下面，改成这样： deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 注：username为你的用户名 然后执行命令：npm install hexo-deployer-git --save 然后，执行配置命令：hexo deploy 然后在浏览器中输入http://username.github.io/ 就行了。 部署步骤每次部署的步骤，可按以下三步来进行： `hexo clean` `hexo generate` `hexo deploy` 报错总结问题1： ERROR Deployer not found: git 或者 ERROR Deployer not found: github 解决方法：npm install hexo-deployer-git --save 问题2： 如发生报错： ERROR Process failed: layout/.DS_Store 那么进入主题里面layout和_partial目录下，使用删除命令：rm-rf.DS_Store 问题3： ERROR Plugin load failed: hexo-server 原因： Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore. 解决方法：npm install hexo-server 问题4： 执行命令hexo server，提示：Usage: hexo .... 原因： 我认为是没有生成本地服务 解决方法：npm install hexo-server --save 问题5： 提示：hexo-server@0.1.2 node_modules/hexo-server .... 表示成功了参考 这个时候再执行：hexo-server 得到: INFOHexois running at http://0.0.0.0:4000/.PressCtrl+C to stop. 这个时候再点击http://0.0.0.0:4000，正常情况下应该是最原始的画面。 这个时候再重新生成静态文件，命令：hexo generate或hexo g 启动本地服务器：hexo server或hexo s 本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。 第二步：部署博客及更新博文在blog文件夹下将博客放入public文件夹中 在blog文件夹下打开git bash，按以下三步进行： `hexo clean` `hexo g` `hexo d` 第三步：安装主题我安装的是nexT主题，可参考主题作者在GitHub的READMEnexT 还有我比较喜欢的主题 yilia 第四步：购买并绑定域名购买域名我是在万网上购买的域名，越出名的后缀越贵，看自己吧，比如.com .cn .net这些域名还需要备案，否则用不了。 绑定域名创建CNAME。 登陆访问github。 进入github中需要关联域名的相应项目。 在该项目下创建CNAME，其CNAME内容即是域名 前往你的DNS服务商 进入”新增解析”界面。 在万网首页点击【进入会员中心】→ 点击【产品管理】下的【域名解析】→ 进入【域名列表】界面 → 点击域名→ 进入【新增解析】界面。 设置域名解析记录。 点击【新增解析】；依次填写相应内容。 “记录类型”选择A；”主机记录”填写www；”解析线路”选择默认； “记录值”填写github提供的IP地址，192.30.252.153或192.30.252.154； “TTL”默认10分钟，自己可以另行设置也可； 最后点击【保存】。 验证域名与github关联是否成功。 先以github的链接方式访问一次，查看界面；再以域名的方式访问一次，查看界面；两者所查看到的界面是一致。 注：若域名不能立即访问，需等待一段时间再访问。当github成功关联到域名后，以github的链接方式进行访问，其会自动转化为域名访问。 参考博客潘柏信的博客 百度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fhello-world.html</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
